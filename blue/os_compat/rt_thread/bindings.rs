/* automatically generated by rust-bindgen 0.69.5 */

pub const RT_NAME_MAX: u32 = 8;
pub const RT_ALIGN_SIZE: u32 = 8;
pub const RT_THREAD_PRIORITY_MAX: u32 = 256;
pub const RT_TICK_PER_SECOND: u32 = 100;
pub const RT_IDLE_HOOK_LIST_SIZE: u32 = 4;
pub const IDLE_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_TIMER_THREAD_PRIO: u32 = 4;
pub const RT_TIMER_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_CONSOLEBUF_SIZE: u32 = 256;
pub const RT_CONSOLE_DEVICE_NAME: &[u8; 6] = b"uart0\0";
pub const RT_VER_NUM: u32 = 327682;
pub const RT_MAIN_THREAD_STACK_SIZE: u32 = 4096;
pub const RT_MAIN_THREAD_PRIORITY: u32 = 10;
pub const FINSH_THREAD_NAME: &[u8; 7] = b"tshell\0";
pub const FINSH_THREAD_PRIORITY: u32 = 20;
pub const FINSH_THREAD_STACK_SIZE: u32 = 4096;
pub const FINSH_HISTORY_LINES: u32 = 5;
pub const FINSH_CMD_SIZE: u32 = 80;
pub const FINSH_ARG_MAX: u32 = 10;
pub const DFS_FD_MAX: u32 = 16;
pub const DFS_FILESYSTEMS_MAX: u32 = 4;
pub const DFS_FILESYSTEM_TYPES_MAX: u32 = 4;
pub const RT_UNAMED_PIPE_NUMBER: u32 = 64;
pub const RT_SERIAL_RB_BUFSZ: u32 = 64;
pub const RT_LIBC_TZ_DEFAULT_HOUR: u32 = 8;
pub const RT_LIBC_TZ_DEFAULT_MIN: u32 = 0;
pub const RT_LIBC_TZ_DEFAULT_SEC: u32 = 0;
pub const UTEST_THR_STACK_SIZE: u32 = 4096;
pub const UTEST_THR_PRIORITY: u32 = 20;
pub const RT_VERSION_MAJOR: u32 = 5;
pub const RT_VERSION_MINOR: u32 = 0;
pub const RT_VERSION_PATCH: u32 = 2;
pub const RT_TRUE: u32 = 1;
pub const RT_FALSE: u32 = 0;
pub const RT_NULL: u32 = 0;
pub const RT_UINT8_MAX: u32 = 255;
pub const RT_UINT16_MAX: u32 = 65535;
pub const RT_UINT32_MAX: u32 = 4294967295;
pub const RT_TICK_MAX: u32 = 4294967295;
pub const RT_SEM_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_HOLD_MAX: u32 = 255;
pub const RT_MB_ENTRY_MAX: u32 = 65535;
pub const RT_MQ_ENTRY_MAX: u32 = 65535;
pub const RT_EVENT_LENGTH: u32 = 32;
pub const RT_MM_PAGE_SIZE: u32 = 4096;
pub const RT_MM_PAGE_MASK: u32 = 4095;
pub const RT_MM_PAGE_BITS: u32 = 12;
pub const RT_EOK: u32 = 0;
pub const RT_ERROR: u32 = 255;
pub const RT_ETIMEOUT: u32 = 116;
pub const RT_EFULL: u32 = 28;
pub const RT_EEMPTY: u32 = 61;
pub const RT_ENOMEM: u32 = 12;
pub const RT_ENOSYS: u32 = 88;
pub const RT_EBUSY: u32 = 16;
pub const RT_EIO: u32 = 5;
pub const RT_EINTR: u32 = 4;
pub const RT_EINVAL: u32 = 22;
pub const RT_ENOENT: u32 = 2;
pub const RT_ENOSPC: u32 = 28;
pub const RT_EPERM: u32 = 1;
pub const RT_ETRAP: u32 = 254;
pub const RT_OBJECT_FLAG_MODULE: u32 = 128;
pub const NAME_MAX: u32 = 8;
pub const RT_TIMER_FLAG_DEACTIVATED: u32 = 0;
pub const RT_TIMER_FLAG_ACTIVATED: u32 = 1;
pub const RT_TIMER_FLAG_ONE_SHOT: u32 = 0;
pub const RT_TIMER_FLAG_PERIODIC: u32 = 2;
pub const RT_TIMER_FLAG_HARD_TIMER: u32 = 0;
pub const RT_TIMER_FLAG_SOFT_TIMER: u32 = 4;
pub const RT_TIMER_FLAG_THREAD_TIMER: u32 = 16;
pub const RT_TIMER_CTRL_SET_TIME: u32 = 0;
pub const RT_TIMER_CTRL_GET_TIME: u32 = 1;
pub const RT_TIMER_CTRL_SET_ONESHOT: u32 = 2;
pub const RT_TIMER_CTRL_SET_PERIODIC: u32 = 3;
pub const RT_TIMER_CTRL_GET_STATE: u32 = 4;
pub const RT_TIMER_CTRL_GET_REMAIN_TIME: u32 = 5;
pub const RT_TIMER_CTRL_GET_FUNC: u32 = 6;
pub const RT_TIMER_CTRL_SET_FUNC: u32 = 7;
pub const RT_TIMER_CTRL_GET_PARM: u32 = 8;
pub const RT_TIMER_CTRL_SET_PARM: u32 = 9;
pub const RT_TIMER_SKIP_LIST_LEVEL: u32 = 1;
pub const RT_TIMER_SKIP_LIST_MASK: u32 = 3;
pub const RT_THREAD_INIT: u32 = 0;
pub const RT_THREAD_CLOSE: u32 = 1;
pub const RT_THREAD_READY: u32 = 2;
pub const RT_THREAD_RUNNING: u32 = 3;
pub const RT_THREAD_SUSPEND_MASK: u32 = 4;
pub const RT_SIGNAL_COMMON_WAKEUP_MASK: u32 = 2;
pub const RT_SIGNAL_KILL_WAKEUP_MASK: u32 = 1;
pub const RT_THREAD_SUSPEND_INTERRUPTIBLE: u32 = 4;
pub const RT_THREAD_SUSPEND: u32 = 4;
pub const RT_THREAD_SUSPEND_KILLABLE: u32 = 6;
pub const RT_THREAD_SUSPEND_UNINTERRUPTIBLE: u32 = 7;
pub const RT_THREAD_STAT_MASK: u32 = 7;
pub const RT_THREAD_STAT_YIELD: u32 = 8;
pub const RT_THREAD_STAT_YIELD_MASK: u32 = 8;
pub const RT_THREAD_STAT_SIGNAL: u32 = 16;
pub const RT_THREAD_STAT_SIGNAL_READY: u32 = 18;
pub const RT_THREAD_STAT_SIGNAL_WAIT: u32 = 32;
pub const RT_THREAD_STAT_SIGNAL_PENDING: u32 = 64;
pub const RT_THREAD_STAT_SIGNAL_MASK: u32 = 240;
pub const RT_THREAD_CTRL_STARTUP: u32 = 0;
pub const RT_THREAD_CTRL_CLOSE: u32 = 1;
pub const RT_THREAD_CTRL_CHANGE_PRIORITY: u32 = 2;
pub const RT_THREAD_CTRL_INFO: u32 = 3;
pub const RT_THREAD_CTRL_BIND_CPU: u32 = 4;
pub const RT_IPC_FLAG_FIFO: u32 = 0;
pub const RT_IPC_FLAG_PRIO: u32 = 1;
pub const RT_IPC_CMD_UNKNOWN: u32 = 0;
pub const RT_IPC_CMD_RESET: u32 = 1;
pub const RT_IPC_CMD_GET_STATE: u32 = 2;
pub const RT_WAITING_FOREVER: i32 = -1;
pub const RT_WAITING_NO: u32 = 0;
pub const RT_EVENT_FLAG_AND: u32 = 1;
pub const RT_EVENT_FLAG_OR: u32 = 2;
pub const RT_EVENT_FLAG_CLEAR: u32 = 4;
pub const RT_DEVICE_FLAG_DEACTIVATE: u32 = 0;
pub const RT_DEVICE_FLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_FLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_FLAG_RDWR: u32 = 3;
pub const RT_DEVICE_FLAG_REMOVABLE: u32 = 4;
pub const RT_DEVICE_FLAG_STANDALONE: u32 = 8;
pub const RT_DEVICE_FLAG_ACTIVATED: u32 = 16;
pub const RT_DEVICE_FLAG_SUSPENDED: u32 = 32;
pub const RT_DEVICE_FLAG_STREAM: u32 = 64;
pub const RT_DEVICE_FLAG_INT_RX: u32 = 256;
pub const RT_DEVICE_FLAG_DMA_RX: u32 = 512;
pub const RT_DEVICE_FLAG_INT_TX: u32 = 1024;
pub const RT_DEVICE_FLAG_DMA_TX: u32 = 2048;
pub const RT_DEVICE_OFLAG_CLOSE: u32 = 0;
pub const RT_DEVICE_OFLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_OFLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_OFLAG_RDWR: u32 = 3;
pub const RT_DEVICE_OFLAG_OPEN: u32 = 8;
pub const RT_DEVICE_OFLAG_MASK: u32 = 3855;
pub const RT_DEVICE_CTRL_RESUME: u32 = 1;
pub const RT_DEVICE_CTRL_SUSPEND: u32 = 2;
pub const RT_DEVICE_CTRL_CONFIG: u32 = 3;
pub const RT_DEVICE_CTRL_CLOSE: u32 = 4;
pub const RT_DEVICE_CTRL_NOTIFY_SET: u32 = 5;
pub const RT_DEVICE_CTRL_SET_INT: u32 = 6;
pub const RT_DEVICE_CTRL_CLR_INT: u32 = 7;
pub const RT_DEVICE_CTRL_GET_INT: u32 = 8;
pub const RT_DEVICE_CTRL_CONSOLE_OFLAG: u32 = 9;
pub const RT_DEVICE_CTRL_MASK: u32 = 31;
pub const RT_DRIVER_MATCH_DTS: u32 = 1;
pub const RT_DEVICE_CTRL_CURSOR_SET_POSITION: u32 = 16;
pub const RT_DEVICE_CTRL_CURSOR_SET_TYPE: u32 = 17;
pub const RT_CPU_CACHE_LINE_SZ: u32 = 32;
pub type rt_bool_t = core::ffi::c_int;
pub type rt_base_t = core::ffi::c_long;
pub type rt_ubase_t = core::ffi::c_ulong;
pub type rt_int8_t = core::ffi::c_schar;
pub type rt_int16_t = core::ffi::c_short;
pub type rt_int32_t = core::ffi::c_int;
pub type rt_uint8_t = core::ffi::c_uchar;
pub type rt_uint16_t = core::ffi::c_ushort;
pub type rt_uint32_t = core::ffi::c_uint;
pub type rt_int64_t = core::ffi::c_longlong;
pub type rt_uint64_t = core::ffi::c_ulonglong;
pub type rt_size_t = rt_ubase_t;
pub type rt_ssize_t = rt_base_t;
pub type rt_err_t = rt_base_t;
pub type rt_time_t = rt_uint32_t;
pub type rt_tick_t = rt_uint32_t;
pub type rt_flag_t = rt_base_t;
pub type rt_dev_t = rt_ubase_t;
pub type rt_off_t = rt_base_t;
pub type rt_atomic_t = rt_base_t;
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type init_fn_t = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_init_desc {
    pub fn_name: *const core::ffi::c_char,
    pub fn_: init_fn_t,
}
#[test]
fn bindgen_test_layout_rt_init_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_init_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_init_desc>(),
        8usize,
        concat!("Size of: ", stringify!(rt_init_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_init_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_init_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_)
        )
    );
}
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_list_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_list_node,
    #[doc = "< point to prev node."]
    pub prev: *mut rt_list_node,
}
#[test]
fn bindgen_test_layout_rt_list_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_list_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_list_node>(),
        8usize,
        concat!("Size of: ", stringify!(rt_list_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_list_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_list_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " Double List structure"]
pub type rt_list_t = rt_list_node;
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_slist_node,
}
#[test]
fn bindgen_test_layout_rt_slist_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_slist_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_slist_node>(),
        4usize,
        concat!("Size of: ", stringify!(rt_slist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_slist_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_slist_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_slist_node),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Single List structure"]
pub type rt_slist_t = rt_slist_node;
pub type TimeoutFn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
#[doc = "< The object is not used."]
pub const rt_object_class_type_RT_Object_Class_Null: rt_object_class_type = 0;
#[doc = "< The object is a process."]
pub const rt_object_class_type_RT_Object_Class_Process: rt_object_class_type = 1;
#[doc = "< The object is a thread."]
pub const rt_object_class_type_RT_Object_Class_Thread: rt_object_class_type = 2;
#[doc = "< The object is a semaphore."]
pub const rt_object_class_type_RT_Object_Class_Semaphore: rt_object_class_type = 3;
#[doc = "< The object is a mutex."]
pub const rt_object_class_type_RT_Object_Class_Mutex: rt_object_class_type = 4;
#[doc = "< The object is a event."]
pub const rt_object_class_type_RT_Object_Class_Event: rt_object_class_type = 5;
#[doc = "< The object is a mail box."]
pub const rt_object_class_type_RT_Object_Class_MailBox: rt_object_class_type = 6;
#[doc = "< The object is a message queue."]
pub const rt_object_class_type_RT_Object_Class_MessageQueue: rt_object_class_type = 7;
#[doc = "< The object is a device."]
pub const rt_object_class_type_RT_Object_Class_Device: rt_object_class_type = 8;
#[doc = "< The object is a timer."]
pub const rt_object_class_type_RT_Object_Class_Timer: rt_object_class_type = 9;
#[doc = "< The object is a memory."]
pub const rt_object_class_type_RT_Object_Class_Memory: rt_object_class_type = 10;
#[doc = "< The object is a custom object"]
pub const rt_object_class_type_RT_Object_Class_Custom: rt_object_class_type = 11;
#[doc = "< The object is unknown."]
pub const rt_object_class_type_RT_Object_Class_Unknown: rt_object_class_type = 12;
pub type rt_object_class_type = core::ffi::c_uint;
pub type rt_spinlock_t = rt_base_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_spinlock {
    pub lock: rt_spinlock_t,
}
#[test]
fn bindgen_test_layout_rt_spinlock() {
    const UNINIT: ::core::mem::MaybeUninit<rt_spinlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(rt_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_spinlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_spinlock),
            "::",
            stringify!(lock)
        )
    );
}
pub const ObjectClassType_ObjectClassUninit: ObjectClassType = 0;
pub const ObjectClassType_ObjectClassProcess: ObjectClassType = 1;
pub const ObjectClassType_ObjectClassThread: ObjectClassType = 2;
pub const ObjectClassType_ObjectClassSemaphore: ObjectClassType = 3;
pub const ObjectClassType_ObjectClassMutex: ObjectClassType = 4;
pub const ObjectClassType_ObjectClassEvent: ObjectClassType = 5;
pub const ObjectClassType_ObjectClassMailBox: ObjectClassType = 6;
pub const ObjectClassType_ObjectClassMessageQueue: ObjectClassType = 7;
pub const ObjectClassType_ObjectClassMemHeap: ObjectClassType = 8;
pub const ObjectClassType_ObjectClassMemPool: ObjectClassType = 9;
pub const ObjectClassType_ObjectClassDevice: ObjectClassType = 10;
pub const ObjectClassType_ObjectClassTimer: ObjectClassType = 11;
pub const ObjectClassType_ObjectClassMemory: ObjectClassType = 12;
pub const ObjectClassType_ObjectClassUnknown: ObjectClassType = 13;
pub type ObjectClassType = rt_uint8_t;
#[doc = " Base kernel Object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object {
    #[doc = " TODO: change type to String\n name of kernel object"]
    pub name: [rt_int8_t; 8usize],
    #[doc = " type of kernel object"]
    pub type_: rt_uint8_t,
    #[doc = " list node of kernel object"]
    pub list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_object() {
    const UNINIT: ::core::mem::MaybeUninit<rt_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_object>(),
        20usize,
        concat!("Size of: ", stringify!(rt_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " Base structure of IPC object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_ipc_object {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " IPC flag to use"]
    pub flag: core::ffi::c_uchar,
    #[doc = " Spin lock IPCObject used"]
    pub spinlock: rt_spinlock,
    #[doc = " Threads pended on this IPC object"]
    pub wait_list: rt_list_t,
    #[doc = " IRQ lock saved"]
    pub irq_saved: rt_int32_t,
}
#[test]
fn bindgen_test_layout_rt_ipc_object() {
    const UNINIT: ::core::mem::MaybeUninit<rt_ipc_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_ipc_object>(),
        40usize,
        concat!("Size of: ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_ipc_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_list) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(wait_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).irq_saved) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(irq_saved)
        )
    );
}
#[doc = " Event flag raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_event {
    #[doc = " Inherit from IPCObject"]
    pub parent: rt_ipc_object,
    #[doc = " Event flog set value"]
    pub set: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_event() {
    const UNINIT: ::core::mem::MaybeUninit<rt_event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_event>(),
        44usize,
        concat!("Size of: ", stringify!(rt_event))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_event>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(set)
        )
    );
}
#[doc = " The timer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer {
    pub parent: rt_object,
    pub timeout_func: TimeoutFn,
    pub parameter: *mut core::ffi::c_void,
    pub init_tick: rt_uint32_t,
    pub timeout_tick: rt_uint32_t,
    pub flag: rt_uint8_t,
    pub node: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_timer() {
    const UNINIT: ::core::mem::MaybeUninit<rt_timer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_timer>(),
        48usize,
        concat!("Size of: ", stringify!(rt_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_timer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_func) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_tick) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_tick) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(node)
        )
    );
}
#[doc = " Stack management structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_stack {
    #[doc = " Current stack pointer"]
    pub sp: *mut rt_size_t,
    #[doc = " Pointer to the lowest address of the stack"]
    pub bottom: *mut rt_uint8_t,
    #[doc = " Stack size"]
    pub size: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_stack() {
    const UNINIT: ::core::mem::MaybeUninit<rt_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_stack>(),
        12usize,
        concat!("Size of: ", stringify!(rt_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_thread {
    pub parent: rt_object,
    #[doc = " the thread list, used in ready_list\\ipc wait_list\\..."]
    pub tlist: rt_list_t,
    #[doc = " thread status"]
    pub stat: core::ffi::c_uchar,
    pub sched_flag_ttmr_set: core::ffi::c_uchar,
    #[doc = " priority manager"]
    pub current_priority: core::ffi::c_uchar,
    pub init_priority: core::ffi::c_uchar,
    pub number: core::ffi::c_uchar,
    pub high_mask: core::ffi::c_uchar,
    pub number_mask: core::ffi::c_uint,
    #[doc = " priority number mask\n time slice"]
    pub init_tick: core::ffi::c_uint,
    pub remaining_tick: core::ffi::c_uint,
    #[doc = " built-in thread timer, used for wait timeout"]
    pub thread_timer: rt_timer,
    #[doc = " stack point and entry"]
    pub stack: rt_stack,
    pub entry: *mut rt_size_t,
    pub parameter: *mut rt_size_t,
    pub cleanup: *mut rt_size_t,
    #[doc = " critical lock count"]
    pub spinlock: rt_spinlock,
    #[doc = " error code"]
    pub error: core::ffi::c_int,
    #[doc = " mutexes holded by this thread"]
    pub taken_object_list: rt_list_t,
    #[doc = " mutex object"]
    pub pending_object: *mut rt_object,
    pub event_set: core::ffi::c_uint,
    pub event_info: core::ffi::c_uchar,
    pub tid: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_thread() {
    const UNINIT: ::core::mem::MaybeUninit<rt_thread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_thread>(),
        152usize,
        concat!("Size of: ", stringify!(rt_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_thread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlist) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_flag_ttmr_set) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(sched_flag_ttmr_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_priority) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(current_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_priority) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_mask) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(high_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_mask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(number_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_tick) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remaining_tick) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(remaining_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_timer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(thread_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_object_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(taken_object_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_object) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(pending_object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_set) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_info) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tid) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex {
    #[doc = " Inherit from IPCObject"]
    pub parent: rt_ipc_object,
    #[doc = " Priority ceiling of mutex"]
    pub ceiling_priority: rt_uint8_t,
    #[doc = " Maximal priority for pending thread"]
    pub priority: rt_uint8_t,
    #[doc = " Numbers of thread hold the mutex"]
    pub hold: rt_uint8_t,
    #[doc = " Current owner of mutex"]
    pub owner: *mut rt_thread,
    #[doc = " The object list taken by thread"]
    pub taken_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mutex() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mutex>(),
        56usize,
        concat!("Size of: ", stringify!(rt_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ceiling_priority) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(ceiling_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hold) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(taken_list)
        )
    );
}
#[doc = " Mailbox raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mailbox {
    #[doc = " Inherit from IPCObject"]
    pub parent: rt_ipc_object,
    #[doc = " Message pool buffer of mailbox"]
    pub msg_pool: *mut rt_uint8_t,
    #[doc = " Message pool buffer size"]
    pub size: rt_uint16_t,
    #[doc = " Index of messages in message pool"]
    pub entry: rt_uint16_t,
    #[doc = " Input offset of the message buffer"]
    pub in_offset: rt_uint16_t,
    #[doc = " Output offset of the message buffer"]
    pub out_offset: rt_uint16_t,
    #[doc = " Sender thread suspended on this mailbox"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mailbox() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mailbox> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mailbox>(),
        60usize,
        concat!("Size of: ", stringify!(rt_mailbox))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mailbox>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mailbox))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_pool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(in_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_offset) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(out_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_sender_thread) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
#[doc = " MessageQueue raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_messagequeue {
    #[doc = " Inherit from IPCObject"]
    pub parent: rt_ipc_object,
    #[doc = " Start address of message queue"]
    pub msg_pool: *mut rt_uint8_t,
    #[doc = " Message size of each message"]
    pub msg_size: rt_uint16_t,
    #[doc = " Max number of messages"]
    pub max_msgs: rt_uint16_t,
    #[doc = " Index of messages in the queue"]
    pub entry: rt_uint16_t,
    #[doc = " List head"]
    pub msg_queue_head: *mut rt_uint8_t,
    #[doc = " List tail"]
    pub msg_queue_tail: *mut rt_uint8_t,
    #[doc = " Pointer indicated the free node of queue"]
    pub msg_queue_free: *mut rt_uint8_t,
    #[doc = " Sender thread suspended on this message queue"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_messagequeue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_messagequeue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_messagequeue>(),
        72usize,
        concat!("Size of: ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_messagequeue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_pool) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_size) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_msgs) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_head) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_tail) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_free) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_sender_thread) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
#[doc = " Semaphore raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_semaphore {
    #[doc = " Inherit from IPCObject"]
    pub parent: rt_ipc_object,
    #[doc = " Value of semaphore"]
    pub value: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_semaphore() {
    const UNINIT: ::core::mem::MaybeUninit<rt_semaphore> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_semaphore>(),
        44usize,
        concat!("Size of: ", stringify!(rt_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_semaphore>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_semaphore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(value)
        )
    );
}
pub type rt_object_t = *mut rt_object;
pub type rt_timer_t = *mut rt_timer;
pub const RT_INTERRUPTIBLE: _bindgen_ty_1 = 0;
pub const RT_KILLABLE: _bindgen_ty_1 = 1;
pub const RT_UNINTERRUPTIBLE: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_cpu {
    _unused: [u8; 0],
}
pub type rt_thread_cleanup_t = ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>;
pub type rt_thread_t = *mut rt_thread;
pub type rt_sem_t = *mut rt_semaphore;
pub type rt_mutex_t = *mut rt_mutex;
pub type rt_event_t = *mut rt_event;
pub type rt_mailbox_t = *mut rt_mailbox;
pub type rt_mq_t = *mut rt_messagequeue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memory {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< Memory management algorithm name"]
    pub algorithm: *const core::ffi::c_char,
    #[doc = "< memory start address"]
    pub address: rt_ubase_t,
    #[doc = "< memory size"]
    pub total: rt_size_t,
    #[doc = "< size used"]
    pub used: rt_size_t,
    #[doc = "< maximum usage"]
    pub max: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_memory() {
    const UNINIT: ::core::mem::MaybeUninit<rt_memory> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_memory>(),
        40usize,
        concat!("Size of: ", stringify!(rt_memory))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_memory>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_memory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(max)
        )
    );
}
pub type rt_mem_t = *mut rt_memory;
pub type rt_smem_t = rt_mem_t;
#[doc = "< character device"]
pub const rt_device_class_type_RT_Device_Class_Char: rt_device_class_type = 0;
#[doc = "< block device"]
pub const rt_device_class_type_RT_Device_Class_Block: rt_device_class_type = 1;
#[doc = "< net interface"]
pub const rt_device_class_type_RT_Device_Class_NetIf: rt_device_class_type = 2;
#[doc = "< memory device"]
pub const rt_device_class_type_RT_Device_Class_MTD: rt_device_class_type = 3;
#[doc = "< CAN device"]
pub const rt_device_class_type_RT_Device_Class_CAN: rt_device_class_type = 4;
#[doc = "< RTC device"]
pub const rt_device_class_type_RT_Device_Class_RTC: rt_device_class_type = 5;
#[doc = "< Sound device"]
pub const rt_device_class_type_RT_Device_Class_Sound: rt_device_class_type = 6;
#[doc = "< Graphic device"]
pub const rt_device_class_type_RT_Device_Class_Graphic: rt_device_class_type = 7;
#[doc = "< I2C bus device"]
pub const rt_device_class_type_RT_Device_Class_I2CBUS: rt_device_class_type = 8;
#[doc = "< USB slave device"]
pub const rt_device_class_type_RT_Device_Class_USBDevice: rt_device_class_type = 9;
#[doc = "< USB host bus"]
pub const rt_device_class_type_RT_Device_Class_USBHost: rt_device_class_type = 10;
#[doc = "< USB OTG bus"]
pub const rt_device_class_type_RT_Device_Class_USBOTG: rt_device_class_type = 11;
#[doc = "< SPI bus device"]
pub const rt_device_class_type_RT_Device_Class_SPIBUS: rt_device_class_type = 12;
#[doc = "< SPI device"]
pub const rt_device_class_type_RT_Device_Class_SPIDevice: rt_device_class_type = 13;
#[doc = "< SDIO bus device"]
pub const rt_device_class_type_RT_Device_Class_SDIO: rt_device_class_type = 14;
#[doc = "< PM pseudo device"]
pub const rt_device_class_type_RT_Device_Class_PM: rt_device_class_type = 15;
#[doc = "< Pipe device"]
pub const rt_device_class_type_RT_Device_Class_Pipe: rt_device_class_type = 16;
#[doc = "< Portal device"]
pub const rt_device_class_type_RT_Device_Class_Portal: rt_device_class_type = 17;
#[doc = "< Timer device"]
pub const rt_device_class_type_RT_Device_Class_Timer: rt_device_class_type = 18;
#[doc = "< Miscellaneous device"]
pub const rt_device_class_type_RT_Device_Class_Miscellaneous: rt_device_class_type = 19;
#[doc = "< Sensor device"]
pub const rt_device_class_type_RT_Device_Class_Sensor: rt_device_class_type = 20;
#[doc = "< Touch device"]
pub const rt_device_class_type_RT_Device_Class_Touch: rt_device_class_type = 21;
#[doc = "< PHY device"]
pub const rt_device_class_type_RT_Device_Class_PHY: rt_device_class_type = 22;
#[doc = "< Security device"]
pub const rt_device_class_type_RT_Device_Class_Security: rt_device_class_type = 23;
#[doc = "< WLAN device"]
pub const rt_device_class_type_RT_Device_Class_WLAN: rt_device_class_type = 24;
#[doc = "< Pin device"]
pub const rt_device_class_type_RT_Device_Class_Pin: rt_device_class_type = 25;
#[doc = "< ADC device"]
pub const rt_device_class_type_RT_Device_Class_ADC: rt_device_class_type = 26;
#[doc = "< DAC device"]
pub const rt_device_class_type_RT_Device_Class_DAC: rt_device_class_type = 27;
#[doc = "< WDT device"]
pub const rt_device_class_type_RT_Device_Class_WDT: rt_device_class_type = 28;
#[doc = "< PWM device"]
pub const rt_device_class_type_RT_Device_Class_PWM: rt_device_class_type = 29;
#[doc = "< Bus device"]
pub const rt_device_class_type_RT_Device_Class_Bus: rt_device_class_type = 30;
#[doc = "< unknown device"]
pub const rt_device_class_type_RT_Device_Class_Unknown: rt_device_class_type = 31;
#[doc = " device (I/O) class type"]
pub type rt_device_class_type = core::ffi::c_uint;
pub type rt_device_t = *mut rt_device;
#[doc = " WaitQueue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue {
    pub flag: rt_uint32_t,
    pub waiting_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_wqueue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_wqueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_wqueue>(),
        12usize,
        concat!("Size of: ", stringify!(rt_wqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_wqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_wqueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waiting_list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(waiting_list)
        )
    );
}
#[doc = " WaitQueue structure"]
pub type rt_wqueue_t = rt_wqueue;
#[doc = " Device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< device type"]
    pub type_: rt_device_class_type,
    #[doc = "< device flag"]
    pub flag: rt_uint16_t,
    #[doc = "< device open flag"]
    pub open_flag: rt_uint16_t,
    #[doc = "< reference count"]
    pub ref_count: rt_uint8_t,
    #[doc = "< 0 - 255"]
    pub device_id: rt_uint8_t,
    pub rx_indicate:
        ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t>,
    pub tx_complete: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: core::ffi::c_int,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    #[doc = "< device private data"]
    pub user_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device>(),
        68usize,
        concat!("Size of: ", stringify!(rt_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_flag) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_indicate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(rx_indicate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_complete) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(tx_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_id {
    pub compatible: *const core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device_id() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_id> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_id>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_id))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_id))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compatible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(compatible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_driver {
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: core::ffi::c_int,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    pub fops: *mut filesystem_ops,
    pub name: *const core::ffi::c_char,
    pub dev_type: rt_device_class_type,
    pub device_size: core::ffi::c_int,
    pub flag: core::ffi::c_int,
    pub dev_match: *const rt_device_id,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub probe_init:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub ops: *const core::ffi::c_void,
    pub drv_priv_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_driver() {
    const UNINIT: ::core::mem::MaybeUninit<rt_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_driver>(),
        68usize,
        concat!("Size of: ", stringify!(rt_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fops) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(device_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_match) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_init) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drv_priv_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(drv_priv_data)
        )
    );
}
pub type rt_driver_t = *mut rt_driver;
#[doc = " Notify structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_notify {
    pub notify: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t)>,
    pub dev: *mut rt_device,
}
#[test]
fn bindgen_test_layout_rt_device_notify() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_notify> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_notify>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_notify))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_notify>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_notify))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(dev)
        )
    );
}
#[doc = " block device geometry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_geometry {
    #[doc = "< count of sectors"]
    pub sector_count: rt_uint64_t,
    #[doc = "< number of bytes per sector"]
    pub bytes_per_sector: rt_uint32_t,
    #[doc = "< number of bytes to erase one block"]
    pub block_size: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_geometry() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_geometry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_geometry>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_geometry>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(sector_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_sector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(block_size)
        )
    );
}
#[doc = " sector arrange struct on block device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_sectors {
    #[doc = "< begin sector"]
    pub sector_begin: rt_uint64_t,
    #[doc = "< end sector"]
    pub sector_end: rt_uint64_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_sectors() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_sectors> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_sectors>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_sectors>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_end)
        )
    );
}
pub const RTGRAPHIC_PIXEL_FORMAT_MONO: _bindgen_ty_2 = 0;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY4: _bindgen_ty_2 = 1;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY16: _bindgen_ty_2 = 2;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB332: _bindgen_ty_2 = 3;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB444: _bindgen_ty_2 = 4;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565: _bindgen_ty_2 = 5;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565P: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR565: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB666: _bindgen_ty_2 = 7;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB888: _bindgen_ty_2 = 8;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR888: _bindgen_ty_2 = 9;
pub const RTGRAPHIC_PIXEL_FORMAT_ARGB888: _bindgen_ty_2 = 10;
pub const RTGRAPHIC_PIXEL_FORMAT_ABGR888: _bindgen_ty_2 = 11;
pub const RTGRAPHIC_PIXEL_FORMAT_RESERVED: _bindgen_ty_2 = 12;
pub type _bindgen_ty_2 = core::ffi::c_uint;
#[doc = " graphic device information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_info {
    #[doc = "< graphic format"]
    pub pixel_format: rt_uint8_t,
    #[doc = "< bits per pixel"]
    pub bits_per_pixel: rt_uint8_t,
    #[doc = "< bytes per line"]
    pub pitch: rt_uint16_t,
    #[doc = "< width of graphic device"]
    pub width: rt_uint16_t,
    #[doc = "< height of graphic device"]
    pub height: rt_uint16_t,
    #[doc = "< frame buffer"]
    pub framebuffer: *mut rt_uint8_t,
    #[doc = "< allocated frame buffer size"]
    pub smem_len: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_info>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixel_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).framebuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smem_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(smem_len)
        )
    );
}
#[doc = " rectangle information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_rect_info {
    #[doc = "< x coordinate"]
    pub x: rt_uint16_t,
    #[doc = "< y coordinate"]
    pub y: rt_uint16_t,
    #[doc = "< width"]
    pub width: rt_uint16_t,
    #[doc = "< height"]
    pub height: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_device_rect_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_rect_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_rect_info>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_rect_info>(),
        2usize,
        concat!("Alignment of ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " graphic operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_ops {
    pub set_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *mut core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_hline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x1: core::ffi::c_int,
            x2: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_vline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y1: core::ffi::c_int,
            y2: core::ffi::c_int,
        ),
    >,
    pub blit_line: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
            size: rt_size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_ops> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_ops>(),
        20usize,
        concat!("Size of: ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_pixel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(set_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_hline) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_hline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_vline) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_vline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blit_line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(blit_line)
        )
    );
}
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_FLUSH: RT_HW_CACHE_OPS = 1;
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_INVALIDATE: RT_HW_CACHE_OPS = 2;
pub type RT_HW_CACHE_OPS = core::ffi::c_uint;
extern "C" {
    pub fn rt_hw_cpu_reset();
}
extern "C" {
    pub fn rt_hw_cpu_shutdown();
}
extern "C" {
    pub fn rt_hw_cpu_arch() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn rt_hw_stack_init(
        entry: *mut core::ffi::c_void,
        parameter: *mut core::ffi::c_void,
        stack_addr: *mut rt_uint8_t,
        exit: *mut core::ffi::c_void,
    ) -> *mut rt_uint8_t;
}
pub type rt_isr_handler_t = ::core::option::Option<
    unsafe extern "C" fn(vector: core::ffi::c_int, param: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_irq_desc {
    pub handler: rt_isr_handler_t,
    pub param: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_irq_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_irq_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_irq_desc>(),
        8usize,
        concat!("Size of: ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_irq_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(param)
        )
    );
}
extern "C" {
    pub fn rt_hw_interrupt_init();
}
extern "C" {
    pub fn rt_hw_interrupt_mask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_umask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_install(
        vector: core::ffi::c_int,
        handler: rt_isr_handler_t,
        param: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> rt_isr_handler_t;
}
extern "C" {
    pub fn rt_hw_interrupt_disable() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_interrupt_enable(level: rt_base_t);
}
extern "C" {
    pub fn rt_hw_interrupt_is_disabled() -> rt_bool_t;
}
extern "C" {
    pub fn rt_sched_unlock(level: rt_base_t);
}
extern "C" {
    pub fn rt_sched_lock() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_context_switch(from: rt_ubase_t, to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_to(to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_interrupt(
        context: *mut core::ffi::c_void,
        from: rt_ubase_t,
        to: rt_ubase_t,
        to_thread: *mut rt_thread,
    );
}
extern "C" {
    pub fn rt_hw_console_output(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_hw_backtrace(fp: *mut rt_uint32_t, thread_entry: rt_ubase_t);
}
extern "C" {
    pub fn rt_hw_show_memory(addr: rt_uint32_t, size: rt_size_t);
}
extern "C" {
    pub fn rt_hw_exception_install(
        exception_handle: ::core::option::Option<
            unsafe extern "C" fn(context: *mut core::ffi::c_void) -> rt_err_t,
        >,
    );
}
extern "C" {
    pub fn rt_hw_us_delay(us: rt_uint32_t);
}
extern "C" {
    pub fn rt_hw_cpu_id() -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_hw_atomic_load(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_store(ptr: *mut rt_atomic_t, val: rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_add(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_sub(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_and(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_or(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_xor(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_exchange(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_flag_clear(ptr: *mut rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_flag_test_and_set(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_compare_exchange_strong(
        ptr: *mut rt_atomic_t,
        expected: *mut rt_atomic_t,
        desired: rt_atomic_t,
    ) -> rt_atomic_t;
}
pub type syscall_func = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall {
    pub name: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub opt: *mut msh_cmd_opt,
    pub func: syscall_func,
}
#[test]
fn bindgen_test_layout_finsh_syscall() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall>(),
        16usize,
        concat!("Size of: ", stringify!(finsh_syscall))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall_item {
    pub next: *mut finsh_syscall_item,
    pub syscall: finsh_syscall,
}
#[test]
fn bindgen_test_layout_finsh_syscall_item() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall_item>(),
        20usize,
        concat!("Size of: ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall_item>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syscall) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(syscall)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msh_cmd_opt {
    pub id: rt_uint32_t,
    pub name: *const core::ffi::c_char,
    pub des: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_msh_cmd_opt() {
    const UNINIT: ::core::mem::MaybeUninit<msh_cmd_opt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<msh_cmd_opt>(),
        12usize,
        concat!("Size of: ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        ::core::mem::align_of::<msh_cmd_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(des)
        )
    );
}
pub type msh_cmd_opt_t = msh_cmd_opt;
extern "C" {
    pub fn msh_opt_list_dump(options: *mut core::ffi::c_void);
}
extern "C" {
    pub fn msh_cmd_opt_id_get(
        argc: core::ffi::c_int,
        argv: *mut *mut core::ffi::c_char,
        options: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut global_syscall_list: *mut finsh_syscall_item;
}
extern "C" {
    pub static mut _syscall_table_begin: *mut finsh_syscall;
}
extern "C" {
    pub static mut _syscall_table_end: *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_syscall_lookup(name: *const core::ffi::c_char) -> *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_set_device(device_name: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object_information {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @addtogroup KernelObject\n @{"]
    pub fn rt_object_get_information(type_: rt_object_class_type) -> *mut rt_object_information;
}
extern "C" {
    pub fn rt_object_get_length(type_: rt_object_class_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_get_pointers(
        type_: rt_object_class_type,
        pointers: *mut rt_object_t,
        maxlen: rt_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_init(
        object: *mut rt_object,
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn rt_object_detach(object: rt_object_t);
}
extern "C" {
    pub fn rt_object_allocate(
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_delete(object: rt_object_t);
}
extern "C" {
    pub fn rt_custom_object_create(
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        data_destroy: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_custom_object_destroy(obj: rt_object_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_object_is_systemobject(object: rt_object_t) -> rt_bool_t;
}
extern "C" {
    pub fn rt_object_get_type(object: rt_object_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_object_find(name: *const core::ffi::c_char, type_: rt_uint8_t) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_get_name(
        object: rt_object_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_object_attach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_detach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_trytake_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_take_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_put_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    #[doc = " @addtogroup Clock\n @{"]
    pub fn rt_tick_get() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_set(tick: rt_tick_t);
}
extern "C" {
    pub fn rt_tick_increase();
}
extern "C" {
    pub fn rt_tick_from_millisecond(ms: rt_int32_t) -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_get_millisecond() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_system_timer_init();
}
extern "C" {
    pub fn rt_system_timer_thread_init();
}
extern "C" {
    pub fn rt_timer_init(
        timer: rt_timer_t,
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    );
}
extern "C" {
    pub fn rt_timer_detach(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_create(
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    ) -> rt_timer_t;
}
extern "C" {
    pub fn rt_timer_delete(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_start(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_stop(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_control(
        timer: rt_timer_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_next_timeout_tick() -> rt_tick_t;
}
extern "C" {
    pub fn rt_timer_check();
}
extern "C" {
    pub fn rt_timer_enter_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    pub fn rt_timer_exit_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    #[doc = " @addtogroup Thread\n @{"]
    pub fn rt_thread_init(
        thread: *mut rt_thread,
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_start: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_detach(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_create(
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_delete(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_self() -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_find(name: *mut core::ffi::c_char) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_startup(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_yield() -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delay(tick: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_mdelay(ms: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_control(
        thread: rt_thread_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend_with_flag(thread: rt_thread_t, suspend_flag: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_resume(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_timeout(parameter: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_thread_get_name(
        thread: rt_thread_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_resume_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_inited_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_idle_init();
}
extern "C" {
    pub fn rt_thread_idle_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_delhook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_gethandler() -> rt_thread_t;
}
extern "C" {
    pub fn rt_system_scheduler_init();
}
extern "C" {
    pub fn rt_system_scheduler_start();
}
extern "C" {
    pub fn rt_schedule();
}
extern "C" {
    pub fn rt_schedule_insert_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_schedule_remove_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_enter_critical();
}
extern "C" {
    pub fn rt_exit_critical();
}
extern "C" {
    pub fn rt_critical_level() -> rt_uint16_t;
}
extern "C" {
    pub fn rt_scheduler_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(from: rt_thread_t, to: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_scheduler_switch_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>,
    );
}
extern "C" {
    pub fn rt_system_heap_init(
        begin_addr: *mut core::ffi::c_void,
        end_addr: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rt_malloc(size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_realloc(ptr: *mut core::ffi::c_void, newsize: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_calloc(count: rt_size_t, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_malloc_align(size: rt_size_t, align: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free_align(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_memory_info(total: *mut rt_size_t, used: *mut rt_size_t, max_used: *mut rt_size_t);
}
extern "C" {
    pub fn rt_malloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut core::ffi::c_void, size: rt_size_t),
        >,
    );
}
extern "C" {
    pub fn rt_free_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(ptr: *mut core::ffi::c_void)>,
    );
}
extern "C" {
    #[doc = " small memory object interface"]
    pub fn rt_smem_init(
        name: *const core::ffi::c_char,
        begin_addr: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_smem_t;
}
extern "C" {
    pub fn rt_smem_detach(m: rt_smem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_smem_alloc(m: rt_smem_t, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_smem_realloc(
        m: rt_smem_t,
        rmem: *mut core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_smem_free(rmem: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_sem_init(
        sem: rt_sem_t,
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_detach(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_create(
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_sem_t;
}
extern "C" {
    pub fn rt_sem_delete(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_interruptible(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_killable(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_trytake(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_release(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_control(
        sem: rt_sem_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_init(
        mutex: rt_mutex_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_detach(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_mutex_t;
}
extern "C" {
    pub fn rt_mutex_delete(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_drop_thread(mutex: rt_mutex_t, thread: rt_thread_t);
}
extern "C" {
    pub fn rt_mutex_setprioceiling(mutex: rt_mutex_t, priority: rt_uint8_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_getprioceiling(mutex: rt_mutex_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_take(mutex: rt_mutex_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_trytake(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_interruptible(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_killable(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_release(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_control(
        mutex: rt_mutex_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_init(
        event: rt_event_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_detach(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_event_t;
}
extern "C" {
    pub fn rt_event_delete(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_send(event: rt_event_t, set: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_interruptible(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_killable(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_control(
        event: rt_event_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_init(
        mb: rt_mailbox_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_detach(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_create(
        name: *const core::ffi::c_char,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mailbox_t;
}
extern "C" {
    pub fn rt_mb_delete(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait(mb: rt_mailbox_t, value: rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_interruptible(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_killable(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_urgent(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv(mb: rt_mailbox_t, value: *mut rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_interruptible(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_killable(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_control(
        mb: rt_mailbox_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mq_message {
    pub next: *mut rt_mq_message,
    pub length: rt_ssize_t,
    pub prio: rt_int32_t,
}
#[test]
fn bindgen_test_layout_rt_mq_message() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mq_message> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mq_message>(),
        12usize,
        concat!("Size of: ", stringify!(rt_mq_message))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mq_message>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mq_message))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(prio)
        )
    );
}
extern "C" {
    pub fn rt_mq_init(
        mq: rt_mq_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        msg_size: rt_size_t,
        pool_size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_detach(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_create(
        name: *const core::ffi::c_char,
        msg_size: rt_size_t,
        max_msgs: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mq_t;
}
extern "C" {
    pub fn rt_mq_delete(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_urgent(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_interruptible(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_killable(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_control(
        mq: rt_mq_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_prio(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        prio: rt_int32_t,
        timeout: rt_int32_t,
        suspend_flag: core::ffi::c_int,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv_prio(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        prio: *mut rt_int32_t,
        timeout: rt_int32_t,
        suspend_flag: core::ffi::c_int,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_thread_defunct_enqueue(thread: rt_thread_t);
}
extern "C" {
    pub fn rt_thread_defunct_dequeue() -> rt_thread_t;
}
extern "C" {
    pub fn rt_spin_lock_init(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_unlock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock_irqsave(lock: *mut rt_spinlock) -> rt_base_t;
}
extern "C" {
    pub fn rt_spin_unlock_irqrestore(lock: *mut rt_spinlock, level: rt_base_t);
}
extern "C" {
    #[doc = " @addtogroup Device\n @{"]
    pub fn rt_device_find(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_register(
        dev: rt_device_t,
        name: *const core::ffi::c_char,
        flags: rt_uint16_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_unregister(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_create(type_: core::ffi::c_int, attach_size: core::ffi::c_int) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_destroy(device: rt_device_t);
}
extern "C" {
    pub fn rt_device_set_rx_indicate(
        dev: rt_device_t,
        rx_ind: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_set_tx_complete(
        dev: rt_device_t,
        tx_done: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_init(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_open(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_close(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_read(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_write(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_control(
        dev: rt_device_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_interrupt_enter();
}
extern "C" {
    pub fn rt_interrupt_leave();
}
extern "C" {
    pub fn rt_interrupt_get_nest() -> rt_uint8_t;
}
extern "C" {
    pub fn rt_interrupt_enter_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_interrupt_leave_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_components_init();
}
extern "C" {
    pub fn rt_components_board_init();
}
extern "C" {
    pub fn rt_kprintf(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_kputs(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_vsprintf(
        dest: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        arg_ptr: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_vsnprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_sprintf(
        buf: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_snprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_console_set_device(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_console_get_device() -> rt_device_t;
}
extern "C" {
    pub fn rt_get_errno() -> rt_err_t;
}
extern "C" {
    pub fn rt_set_errno(no: rt_err_t);
}
extern "C" {
    pub fn _rt_errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn rt_strerror(error: rt_err_t) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn __rt_ffs(value: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_memset(
        src: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcpy(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcmp(
        cs: *const core::ffi::c_void,
        ct: *const core::ffi::c_void,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strdup(s: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strnlen(s: *const core::ffi::c_char, maxlen: rt_ubase_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_strstr(
        str1: *const core::ffi::c_char,
        str2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strcasecmp(a: *const core::ffi::c_char, b: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcpy(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncpy(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        n: rt_size_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncmp(
        cs: *const core::ffi::c_char,
        ct: *const core::ffi::c_char,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcmp(cs: *const core::ffi::c_char, ct: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strlen(src: *const core::ffi::c_char) -> rt_size_t;
}
extern "C" {
    pub fn rt_show_version();
}
extern "C" {
    pub static mut rt_assert_hook: ::core::option::Option<
        unsafe extern "C" fn(
            ex: *const core::ffi::c_char,
            func: *const core::ffi::c_char,
            line: rt_size_t,
        ),
    >;
}
extern "C" {
    pub fn rt_assert_set_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(
                ex: *const core::ffi::c_char,
                func: *const core::ffi::c_char,
                line: rt_size_t,
            ),
        >,
    );
}
extern "C" {
    pub fn rt_assert_handler(
        ex: *const core::ffi::c_char,
        func: *const core::ffi::c_char,
        line: rt_size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filesystem_ops {
    pub _address: u8,
}

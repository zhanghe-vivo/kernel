use std::{collections::HashMap, env};

fn main() {
    println!("cargo::rustc-check-cfg=cfg(hardware_schedule)");

    let target = env::var("TARGET").unwrap();

    // Set cargo flags from target toolchain
    // Source: `cortex-m` crate
    if target.starts_with("thumb") {
        println!("cargo:rustc-cfg=hardware_schedule");
    } else {
        //println!("cargo:rustc-cfg=fast_schedule");
    }

    let compat_os = env::var("COMPAT_OS").unwrap_or_else(|_e| String::from(""));

    if compat_os == "rt_thread" {
        let rename_list = HashMap::from([
            ("KObjectBase".to_string(), "rt_object".to_string()),
            ("Stack".to_string(), "rt_stack".to_string()),
            ("RtThread".to_string(), "rt_thread".to_string()),
            ("IPCObject".to_string(), "rt_ipc_object".to_string()),
            ("RtSemaphore".to_string(), "rt_semaphore".to_string()),
            ("RtMutex".to_string(), "rt_mutex".to_string()),
            ("RtEvent".to_string(), "rt_event".to_string()),
            ("RtMailbox".to_string(), "rt_mailbox".to_string()),
            ("RtMessage".to_string(), "rt_mq_message".to_string()),
            ("RtMessageQueue".to_string(), "rt_messagequeue".to_string()),
            ("Timer".to_string(), "rt_timer".to_string()),
            ("ListHead".to_string(), "rt_list_t".to_string()),
            (
                "ObjectInformation".to_string(),
                "rt_object_information".to_string(),
            ),
        ]);

        let defines = HashMap::from([
            (
                "feature = RT_USING_SMP".to_string(),
                "RT_USING_SMP".to_string(),
            ),
            (
                "feature = RT_USING_MUTEX".to_string(),
                "RT_USING_MUTEX".to_string(),
            ),
            (
                "feature = RT_USING_SEMAPHORE".to_string(),
                "RT_USING_SEMAPHORE".to_string(),
            ),
            (
                "feature = RT_USING_EVENT".to_string(),
                "RT_USING_EVENT".to_string(),
            ),
            (
                "feature = RT_USING_MAILBOX".to_string(),
                "RT_USING_MAILBOX".to_string(),
            ),
            (
                "feature = RT_USING_MESSAGEQUEUE".to_string(),
                "RT_USING_MESSAGEQUEUE".to_string(),
            ),
            (
                "feature = RT_DEBUGING_SPINLOCK".to_string(),
                "RT_DEBUGING_SPINLOCK".to_string(),
            ),
        ]);

        // cbindgen
        let config = cbindgen::Config {
            include_guard: Some("KERN_RUST_WRAPPER_H".to_string()),
            autogen_warning: Some(
                "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
                    .to_string(),
            ),
            documentation: true,
            export: cbindgen::ExportConfig {
                item_types: vec![
                    cbindgen::ItemType::Structs,
                    cbindgen::ItemType::Enums,
                    cbindgen::ItemType::Typedefs,
                ],
                exclude: vec!["ListHead".to_string()],
                rename: rename_list,
                ..Default::default()
            },
            defines,
            ..Default::default()
        };

        let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        cbindgen::Builder::new()
            .with_config(config)
            .with_crate(crate_dir)
            .with_no_includes()
            .with_language(cbindgen::Language::C)
            .generate()
            .expect("Unable to generate bindings")
            .write_to_file("include/rust_wrapper.inc");
    }
}

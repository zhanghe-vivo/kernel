use enum_iterator::all;
use std::{collections::HashMap, env};
fn main() {
    feature_to_cargo();

    println!("cargo::rustc-check-cfg=cfg(hardware_schedule)");

    let target = env::var("TARGET").unwrap();

    // Set cargo flags from target toolchain
    // Source: `cortex-m` crate
    if target.starts_with("thumb") {
        println!("cargo:rustc-cfg=hardware_schedule");
    } else {
        //println!("cargo:rustc-cfg=fast_schedule");
    }

    let os_adapter = env::var("OS_ADAPTER").unwrap_or_else(|_e| String::from(""));

    if os_adapter == "rt_thread" {
        let rename_list = HashMap::from([
            ("KObjectBase".to_string(), "rt_object".to_string()),
            ("Stack".to_string(), "rt_stack".to_string()),
            ("Thread".to_string(), "rt_thread".to_string()),
            ("IPCObject".to_string(), "rt_ipc_object".to_string()),
            ("Semaphore".to_string(), "rt_semaphore".to_string()),
            ("Mutex".to_string(), "rt_mutex".to_string()),
            ("Event".to_string(), "rt_event".to_string()),
            ("CondVar".to_string(), "rt_condvar".to_string()),
            ("RwLock".to_string(), "rt_rwlock".to_string()),
            ("Mailbox".to_string(), "rt_mailbox".to_string()),
            ("MessageQueue".to_string(), "rt_messagequeue".to_string()),
            ("Timer".to_string(), "rt_timer".to_string()),
            ("ListHead".to_string(), "rt_list_t".to_string()),
            (
                "ObjectInformation".to_string(),
                "rt_object_information".to_string(),
            ),
        ]);

        let defines = HashMap::from([
            ("feature = smp".to_string(), "RT_USING_SMP".to_string()),
            ("feature = mutex".to_string(), "RT_USING_MUTEX".to_string()),
            (
                "feature = semaphore".to_string(),
                "RT_USING_SEMAPHORE".to_string(),
            ),
            (
                "feature = condvar".to_string(),
                "RT_USING_CONDVAR".to_string(),
            ),
            (
                "feature = rwlock".to_string(),
                "RT_USING_RWLOCK".to_string(),
            ),
            (
                "feature = mailbox".to_string(),
                "RT_USING_MAILBOX".to_string(),
            ),
            (
                "feature = messagequeue".to_string(),
                "RT_USING_MESSAGEQUEUE".to_string(),
            ),
            ("feature = event".to_string(), "RT_USING_EVENT".to_string()),
            (
                "feature = debugging_spinlock".to_string(),
                "RT_DEBUGING_SPINLOCK".to_string(),
            ),
        ]);

        // cbindgen
        let config = cbindgen::Config {
            include_guard: Some("KERN_RUST_WRAPPER_H".to_string()),
            autogen_warning: Some(
                "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
                    .to_string(),
            ),
            documentation: true,
            export: cbindgen::ExportConfig {
                item_types: vec![
                    cbindgen::ItemType::Structs,
                    cbindgen::ItemType::Enums,
                    cbindgen::ItemType::Typedefs,
                ],
                exclude: vec!["ListHead".to_string()],
                rename: rename_list,
                ..Default::default()
            },
            defines,
            ..Default::default()
        };

        let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        cbindgen::Builder::new()
            .with_config(config)
            .with_crate(crate_dir)
            .with_no_includes()
            .with_language(cbindgen::Language::C)
            .generate()
            .expect("Unable to generate bindings")
            .write_to_file("../adapter/rt_thread/include/rust_wrapper.inc");
    }
}

fn feature_to_cargo() {
    for feature in all::<blue_kconfig::Feature>() {
        if feature.is_enabled() {
            println!("cargo:rustc-cfg=feature=\"{}\"", feature.to_string());
        }
    }
}

/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const RT_NAME_MAX: u32 = 8;
pub const RT_ALIGN_SIZE: u32 = 8;
pub const RT_THREAD_PRIORITY_MAX: u32 = 256;
pub const RT_TICK_PER_SECOND: u32 = 100;
pub const RT_IDLE_HOOK_LIST_SIZE: u32 = 4;
pub const IDLE_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_TIMER_THREAD_PRIO: u32 = 4;
pub const RT_TIMER_THREAD_STACK_SIZE: u32 = 2048;
pub const RT_CONSOLEBUF_SIZE: u32 = 256;
pub const RT_CONSOLE_DEVICE_NAME: &[u8; 6] = b"uart0\0";
pub const RT_VER_NUM: u32 = 327682;
pub const RT_MAIN_THREAD_STACK_SIZE: u32 = 4096;
pub const RT_MAIN_THREAD_PRIORITY: u32 = 10;
pub const FINSH_THREAD_NAME: &[u8; 7] = b"tshell\0";
pub const FINSH_THREAD_PRIORITY: u32 = 20;
pub const FINSH_THREAD_STACK_SIZE: u32 = 4096;
pub const FINSH_HISTORY_LINES: u32 = 5;
pub const FINSH_CMD_SIZE: u32 = 80;
pub const FINSH_ARG_MAX: u32 = 10;
pub const DFS_FD_MAX: u32 = 16;
pub const DFS_FILESYSTEMS_MAX: u32 = 4;
pub const DFS_FILESYSTEM_TYPES_MAX: u32 = 4;
pub const RT_UNAMED_PIPE_NUMBER: u32 = 64;
pub const RT_SERIAL_RB_BUFSZ: u32 = 64;
pub const RT_LIBC_TZ_DEFAULT_HOUR: u32 = 8;
pub const RT_LIBC_TZ_DEFAULT_MIN: u32 = 0;
pub const RT_LIBC_TZ_DEFAULT_SEC: u32 = 0;
pub const UTEST_THR_STACK_SIZE: u32 = 4096;
pub const UTEST_THR_PRIORITY: u32 = 20;
pub const RT_VERSION_MAJOR: u32 = 5;
pub const RT_VERSION_MINOR: u32 = 0;
pub const RT_VERSION_PATCH: u32 = 2;
pub const RT_TRUE: u32 = 1;
pub const RT_FALSE: u32 = 0;
pub const RT_NULL: u32 = 0;
pub const RT_UINT8_MAX: u32 = 255;
pub const RT_UINT16_MAX: u32 = 65535;
pub const RT_UINT32_MAX: u32 = 4294967295;
pub const RT_TICK_MAX: u32 = 4294967295;
pub const RT_SEM_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_HOLD_MAX: u32 = 255;
pub const RT_MB_ENTRY_MAX: u32 = 65535;
pub const RT_MQ_ENTRY_MAX: u32 = 65535;
pub const RT_EVENT_LENGTH: u32 = 32;
pub const RT_MM_PAGE_SIZE: u32 = 4096;
pub const RT_MM_PAGE_MASK: u32 = 4095;
pub const RT_MM_PAGE_BITS: u32 = 12;
pub const RT_EOK: u32 = 0;
pub const RT_ERROR: u32 = 255;
pub const RT_ETIMEOUT: u32 = 116;
pub const RT_EFULL: u32 = 28;
pub const RT_EEMPTY: u32 = 61;
pub const RT_ENOMEM: u32 = 12;
pub const RT_ENOSYS: u32 = 88;
pub const RT_EBUSY: u32 = 16;
pub const RT_EIO: u32 = 5;
pub const RT_EINTR: u32 = 4;
pub const RT_EINVAL: u32 = 22;
pub const RT_ENOENT: u32 = 2;
pub const RT_ENOSPC: u32 = 28;
pub const RT_EPERM: u32 = 1;
pub const RT_ETRAP: u32 = 254;
pub const RT_OBJECT_FLAG_MODULE: u32 = 128;
pub const NAME_MAX: u32 = 8;
pub const ThreadState_INIT: u32 = 0;
pub const ThreadState_CLOSE: u32 = 1;
pub const ThreadState_READY: u32 = 2;
pub const ThreadState_RUNNING: u32 = 3;
pub const ThreadState_SUSPENDED: u32 = 4;
pub const ThreadState_STATE_MASK: u32 = 7;
pub const ThreadState_YIELD: u32 = 8;
pub const TimerState_DEACTIVATED: u32 = 0;
pub const TimerState_ONE_SHOT: u32 = 0;
pub const TimerState_ACTIVATED: u32 = 1;
pub const TimerState_PERIODIC: u32 = 2;
pub const TimerState_HARD_TIMER: u32 = 0;
pub const TimerState_SOFT_TIMER: u32 = 4;
pub const TimerState_THREAD_TIMER: u32 = 16;
pub const RT_TIMER_FLAG_DEACTIVATED: u32 = 0;
pub const RT_TIMER_FLAG_ACTIVATED: u32 = 1;
pub const RT_TIMER_FLAG_ONE_SHOT: u32 = 0;
pub const RT_TIMER_FLAG_PERIODIC: u32 = 2;
pub const RT_TIMER_FLAG_HARD_TIMER: u32 = 0;
pub const RT_TIMER_FLAG_SOFT_TIMER: u32 = 4;
pub const RT_TIMER_FLAG_THREAD_TIMER: u32 = 16;
pub const RT_TIMER_CTRL_SET_TIME: u32 = 0;
pub const RT_TIMER_CTRL_GET_TIME: u32 = 1;
pub const RT_TIMER_CTRL_SET_ONESHOT: u32 = 2;
pub const RT_TIMER_CTRL_SET_PERIODIC: u32 = 3;
pub const RT_TIMER_CTRL_GET_STATE: u32 = 4;
pub const RT_TIMER_CTRL_GET_REMAIN_TIME: u32 = 5;
pub const RT_TIMER_CTRL_GET_FUNC: u32 = 6;
pub const RT_TIMER_CTRL_SET_FUNC: u32 = 7;
pub const RT_TIMER_CTRL_GET_PARM: u32 = 8;
pub const RT_TIMER_CTRL_SET_PARM: u32 = 9;
pub const RT_TIMER_SKIP_LIST_LEVEL: u32 = 1;
pub const RT_TIMER_SKIP_LIST_MASK: u32 = 3;
pub const RT_THREAD_INIT: u32 = 0;
pub const RT_THREAD_CLOSE: u32 = 1;
pub const RT_THREAD_READY: u32 = 2;
pub const RT_THREAD_RUNNING: u32 = 3;
pub const RT_THREAD_SUSPEND_MASK: u32 = 4;
pub const RT_SIGNAL_COMMON_WAKEUP_MASK: u32 = 2;
pub const RT_SIGNAL_KILL_WAKEUP_MASK: u32 = 1;
pub const RT_THREAD_SUSPEND_INTERRUPTIBLE: u32 = 4;
pub const RT_THREAD_SUSPEND: u32 = 4;
pub const RT_THREAD_SUSPEND_KILLABLE: u32 = 6;
pub const RT_THREAD_SUSPEND_UNINTERRUPTIBLE: u32 = 7;
pub const RT_THREAD_STAT_MASK: u32 = 7;
pub const RT_THREAD_STAT_YIELD: u32 = 8;
pub const RT_THREAD_STAT_YIELD_MASK: u32 = 8;
pub const RT_THREAD_STAT_SIGNAL: u32 = 16;
pub const RT_THREAD_STAT_SIGNAL_READY: u32 = 18;
pub const RT_THREAD_STAT_SIGNAL_WAIT: u32 = 32;
pub const RT_THREAD_STAT_SIGNAL_PENDING: u32 = 64;
pub const RT_THREAD_STAT_SIGNAL_MASK: u32 = 240;
pub const RT_THREAD_CTRL_STARTUP: u32 = 0;
pub const RT_THREAD_CTRL_CLOSE: u32 = 1;
pub const RT_THREAD_CTRL_CHANGE_PRIORITY: u32 = 2;
pub const RT_THREAD_CTRL_INFO: u32 = 3;
pub const RT_THREAD_CTRL_BIND_CPU: u32 = 4;
pub const RT_IPC_FLAG_FIFO: u32 = 0;
pub const RT_IPC_FLAG_PRIO: u32 = 1;
pub const RT_IPC_CMD_UNKNOWN: u32 = 0;
pub const RT_IPC_CMD_RESET: u32 = 1;
pub const RT_IPC_CMD_GET_STATE: u32 = 2;
pub const RT_WAITING_FOREVER: i32 = -1;
pub const RT_WAITING_NO: u32 = 0;
pub const RT_EVENT_FLAG_AND: u32 = 1;
pub const RT_EVENT_FLAG_OR: u32 = 2;
pub const RT_EVENT_FLAG_CLEAR: u32 = 4;
pub const RT_DEVICE_FLAG_DEACTIVATE: u32 = 0;
pub const RT_DEVICE_FLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_FLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_FLAG_RDWR: u32 = 3;
pub const RT_DEVICE_FLAG_REMOVABLE: u32 = 4;
pub const RT_DEVICE_FLAG_STANDALONE: u32 = 8;
pub const RT_DEVICE_FLAG_ACTIVATED: u32 = 16;
pub const RT_DEVICE_FLAG_SUSPENDED: u32 = 32;
pub const RT_DEVICE_FLAG_STREAM: u32 = 64;
pub const RT_DEVICE_FLAG_INT_RX: u32 = 256;
pub const RT_DEVICE_FLAG_DMA_RX: u32 = 512;
pub const RT_DEVICE_FLAG_INT_TX: u32 = 1024;
pub const RT_DEVICE_FLAG_DMA_TX: u32 = 2048;
pub const RT_DEVICE_OFLAG_CLOSE: u32 = 0;
pub const RT_DEVICE_OFLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_OFLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_OFLAG_RDWR: u32 = 3;
pub const RT_DEVICE_OFLAG_OPEN: u32 = 8;
pub const RT_DEVICE_OFLAG_MASK: u32 = 3855;
pub const RT_DEVICE_CTRL_RESUME: u32 = 1;
pub const RT_DEVICE_CTRL_SUSPEND: u32 = 2;
pub const RT_DEVICE_CTRL_CONFIG: u32 = 3;
pub const RT_DEVICE_CTRL_CLOSE: u32 = 4;
pub const RT_DEVICE_CTRL_NOTIFY_SET: u32 = 5;
pub const RT_DEVICE_CTRL_SET_INT: u32 = 6;
pub const RT_DEVICE_CTRL_CLR_INT: u32 = 7;
pub const RT_DEVICE_CTRL_GET_INT: u32 = 8;
pub const RT_DEVICE_CTRL_CONSOLE_OFLAG: u32 = 9;
pub const RT_DEVICE_CTRL_MASK: u32 = 31;
pub const RT_DRIVER_MATCH_DTS: u32 = 1;
pub const RT_DEVICE_CTRL_CURSOR_SET_POSITION: u32 = 16;
pub const RT_DEVICE_CTRL_CURSOR_SET_TYPE: u32 = 17;
pub const RT_CPU_CACHE_LINE_SZ: u32 = 32;
pub const RT_DATAQUEUE_EVENT_UNKNOWN: u32 = 0;
pub const RT_DATAQUEUE_EVENT_POP: u32 = 1;
pub const RT_DATAQUEUE_EVENT_PUSH: u32 = 2;
pub const RT_DATAQUEUE_EVENT_LWM: u32 = 3;
pub const RT_WQ_FLAG_CLEAN: u32 = 0;
pub const RT_WQ_FLAG_WAKEUP: u32 = 1;
pub const BAUD_RATE_2400: u32 = 2400;
pub const BAUD_RATE_4800: u32 = 4800;
pub const BAUD_RATE_9600: u32 = 9600;
pub const BAUD_RATE_19200: u32 = 19200;
pub const BAUD_RATE_38400: u32 = 38400;
pub const BAUD_RATE_57600: u32 = 57600;
pub const BAUD_RATE_115200: u32 = 115200;
pub const BAUD_RATE_230400: u32 = 230400;
pub const BAUD_RATE_460800: u32 = 460800;
pub const BAUD_RATE_500000: u32 = 500000;
pub const BAUD_RATE_921600: u32 = 921600;
pub const BAUD_RATE_2000000: u32 = 2000000;
pub const BAUD_RATE_2500000: u32 = 2500000;
pub const BAUD_RATE_3000000: u32 = 3000000;
pub const DATA_BITS_5: u32 = 5;
pub const DATA_BITS_6: u32 = 6;
pub const DATA_BITS_7: u32 = 7;
pub const DATA_BITS_8: u32 = 8;
pub const DATA_BITS_9: u32 = 9;
pub const STOP_BITS_1: u32 = 0;
pub const STOP_BITS_2: u32 = 1;
pub const STOP_BITS_3: u32 = 2;
pub const STOP_BITS_4: u32 = 3;
pub const PARITY_NONE: u32 = 0;
pub const PARITY_ODD: u32 = 1;
pub const PARITY_EVEN: u32 = 2;
pub const BIT_ORDER_LSB: u32 = 0;
pub const BIT_ORDER_MSB: u32 = 1;
pub const NRZ_NORMAL: u32 = 0;
pub const NRZ_INVERTED: u32 = 1;
pub const RT_SERIAL_EVENT_RX_IND: u32 = 1;
pub const RT_SERIAL_EVENT_TX_DONE: u32 = 2;
pub const RT_SERIAL_EVENT_RX_DMADONE: u32 = 3;
pub const RT_SERIAL_EVENT_TX_DMADONE: u32 = 4;
pub const RT_SERIAL_EVENT_RX_TIMEOUT: u32 = 5;
pub const RT_SERIAL_DMA_RX: u32 = 1;
pub const RT_SERIAL_DMA_TX: u32 = 2;
pub const RT_SERIAL_RX_INT: u32 = 1;
pub const RT_SERIAL_TX_INT: u32 = 2;
pub const RT_SERIAL_ERR_OVERRUN: u32 = 1;
pub const RT_SERIAL_ERR_FRAMING: u32 = 2;
pub const RT_SERIAL_ERR_PARITY: u32 = 3;
pub const RT_SERIAL_TX_DATAQUEUE_SIZE: u32 = 2048;
pub const RT_SERIAL_TX_DATAQUEUE_LWM: u32 = 30;
pub const RT_SERIAL_FLOWCONTROL_CTSRTS: u32 = 1;
pub const RT_SERIAL_FLOWCONTROL_NONE: u32 = 0;
pub const PIN_NONE: i32 = -1;
pub const PIN_LOW: u32 = 0;
pub const PIN_HIGH: u32 = 1;
pub const PIN_MODE_OUTPUT: u32 = 0;
pub const PIN_MODE_INPUT: u32 = 1;
pub const PIN_MODE_INPUT_PULLUP: u32 = 2;
pub const PIN_MODE_INPUT_PULLDOWN: u32 = 3;
pub const PIN_MODE_OUTPUT_OD: u32 = 4;
pub const PIN_IRQ_MODE_RISING: u32 = 0;
pub const PIN_IRQ_MODE_FALLING: u32 = 1;
pub const PIN_IRQ_MODE_RISING_FALLING: u32 = 2;
pub const PIN_IRQ_MODE_HIGH_LEVEL: u32 = 3;
pub const PIN_IRQ_MODE_LOW_LEVEL: u32 = 4;
pub const PIN_IRQ_DISABLE: u32 = 0;
pub const PIN_IRQ_ENABLE: u32 = 1;
pub const PIN_IRQ_PIN_NONE: i32 = -1;
pub type rt_bool_t = core::ffi::c_int;
pub type rt_base_t = core::ffi::c_long;
pub type rt_ubase_t = core::ffi::c_ulong;
pub type rt_int8_t = core::ffi::c_schar;
pub type rt_int16_t = core::ffi::c_short;
pub type rt_int32_t = core::ffi::c_int;
pub type rt_uint8_t = core::ffi::c_uchar;
pub type rt_uint16_t = core::ffi::c_ushort;
pub type rt_uint32_t = core::ffi::c_uint;
pub type rt_int64_t = core::ffi::c_longlong;
pub type rt_uint64_t = core::ffi::c_ulonglong;
pub type rt_size_t = rt_ubase_t;
pub type rt_ssize_t = rt_base_t;
pub type rt_err_t = rt_base_t;
pub type rt_time_t = rt_uint32_t;
pub type rt_tick_t = rt_uint32_t;
pub type rt_flag_t = rt_base_t;
pub type rt_dev_t = rt_ubase_t;
pub type rt_off_t = rt_base_t;
pub type rt_atomic_t = rt_base_t;
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type init_fn_t = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_init_desc {
    pub fn_name: *const core::ffi::c_char,
    pub fn_: init_fn_t,
}
#[test]
fn bindgen_test_layout_rt_init_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_init_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_init_desc>(),
        8usize,
        concat!("Size of: ", stringify!(rt_init_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_init_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_init_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_)
        )
    );
}
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_list_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_list_node,
    #[doc = "< point to prev node."]
    pub prev: *mut rt_list_node,
}
#[test]
fn bindgen_test_layout_rt_list_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_list_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_list_node>(),
        8usize,
        concat!("Size of: ", stringify!(rt_list_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_list_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_list_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " Double List structure"]
pub type rt_list_t = rt_list_node;
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_slist_node,
}
#[test]
fn bindgen_test_layout_rt_slist_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_slist_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_slist_node>(),
        4usize,
        concat!("Size of: ", stringify!(rt_slist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_slist_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_slist_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_slist_node),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Single List structure"]
pub type rt_slist_t = rt_slist_node;
pub type TimeoutFn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut core::ffi::c_void)>;
#[doc = "< The object is not used."]
pub const rt_object_class_type_RT_Object_Class_Null: rt_object_class_type = 0;
#[doc = "< The object is a process."]
pub const rt_object_class_type_RT_Object_Class_Process: rt_object_class_type = 1;
#[doc = "< The object is a thread."]
pub const rt_object_class_type_RT_Object_Class_Thread: rt_object_class_type = 2;
#[doc = "< The object is a semaphore."]
pub const rt_object_class_type_RT_Object_Class_Semaphore: rt_object_class_type = 3;
#[doc = "< The object is a mutex."]
pub const rt_object_class_type_RT_Object_Class_Mutex: rt_object_class_type = 4;
#[doc = "< The object is a event."]
pub const rt_object_class_type_RT_Object_Class_Event: rt_object_class_type = 5;
#[doc = "< The object is a mail box."]
pub const rt_object_class_type_RT_Object_Class_MailBox: rt_object_class_type = 6;
#[doc = "< The object is a message queue."]
pub const rt_object_class_type_RT_Object_Class_MessageQueue: rt_object_class_type = 7;
#[doc = "< The object is a device."]
pub const rt_object_class_type_RT_Object_Class_Device: rt_object_class_type = 8;
#[doc = "< The object is a timer."]
pub const rt_object_class_type_RT_Object_Class_Timer: rt_object_class_type = 9;
#[doc = "< The object is a memory."]
pub const rt_object_class_type_RT_Object_Class_Memory: rt_object_class_type = 10;
#[doc = "< The object is a custom object"]
pub const rt_object_class_type_RT_Object_Class_Custom: rt_object_class_type = 11;
#[doc = "< The object is unknown."]
pub const rt_object_class_type_RT_Object_Class_Unknown: rt_object_class_type = 12;
pub type rt_object_class_type = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_spinlock {
    pub lock: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_spinlock() {
    const UNINIT: ::core::mem::MaybeUninit<rt_spinlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(rt_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_spinlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_spinlock),
            "::",
            stringify!(lock)
        )
    );
}
pub const ObjectClassType_ObjectClassUninit: ObjectClassType = 0;
pub const ObjectClassType_ObjectClassProcess: ObjectClassType = 1;
pub const ObjectClassType_ObjectClassThread: ObjectClassType = 2;
pub const ObjectClassType_ObjectClassSemaphore: ObjectClassType = 3;
pub const ObjectClassType_ObjectClassMutex: ObjectClassType = 4;
pub const ObjectClassType_ObjectClassCondVar: ObjectClassType = 5;
pub const ObjectClassType_ObjectClassRwLock: ObjectClassType = 6;
pub const ObjectClassType_ObjectClassEvent: ObjectClassType = 7;
pub const ObjectClassType_ObjectClassMailBox: ObjectClassType = 8;
pub const ObjectClassType_ObjectClassMessageQueue: ObjectClassType = 9;
pub const ObjectClassType_ObjectClassMemHeap: ObjectClassType = 10;
pub const ObjectClassType_ObjectClassMemPool: ObjectClassType = 11;
pub const ObjectClassType_ObjectClassDevice: ObjectClassType = 12;
pub const ObjectClassType_ObjectClassTimer: ObjectClassType = 13;
pub const ObjectClassType_ObjectClassMemory: ObjectClassType = 14;
pub const ObjectClassType_ObjectClassUnknown: ObjectClassType = 15;
pub type ObjectClassType = rt_uint8_t;
pub type IdleHookFn = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " Base kernel Object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object {
    #[doc = " TODO: change type to String\n name of kernel object"]
    pub name: [rt_int8_t; 8usize],
    #[doc = " type of kernel object"]
    pub type_: rt_uint8_t,
    #[doc = " list node of kernel object"]
    pub list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_object() {
    const UNINIT: ::core::mem::MaybeUninit<rt_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_object>(),
        20usize,
        concat!("Size of: ", stringify!(rt_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(list)
        )
    );
}
#[doc = " WaitQueue for pending threads"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WaitQueue {
    #[doc = " WaitQueue impl by ListHead"]
    pub working_queue: rt_list_t,
    #[doc = " WaitQueue working mode, FIFO or PRIO"]
    pub waiting_mode: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_WaitQueue() {
    const UNINIT: ::core::mem::MaybeUninit<WaitQueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WaitQueue>(),
        12usize,
        concat!("Size of: ", stringify!(WaitQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<WaitQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(WaitQueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).working_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitQueue),
            "::",
            stringify!(working_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waiting_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WaitQueue),
            "::",
            stringify!(waiting_mode)
        )
    );
}
#[doc = " System queue for kernel use on IPC"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysQueue {
    #[doc = " Queue item size"]
    pub item_size: rt_size_t,
    #[doc = " Queue item max count"]
    pub item_max_count: rt_size_t,
    #[doc = " Count of items in queue"]
    pub item_in_queue: rt_size_t,
    #[doc = " Queue raw buffer pointer"]
    pub queue_buf: *mut rt_uint8_t,
    #[doc = " Queue memory size"]
    pub queue_buf_size: rt_size_t,
    #[doc = " If the queue buffer from external, this will be true"]
    pub is_storage_from_external: rt_bool_t,
    #[doc = " Ringbuffer read position"]
    pub read_pos: rt_size_t,
    #[doc = " Ringbuffer write position"]
    pub write_pos: rt_size_t,
    #[doc = " Queue head pointer"]
    pub head: *mut rt_uint8_t,
    #[doc = " Queue tail pointer"]
    pub tail: *mut rt_uint8_t,
    #[doc = " Pointer to first 'free to use' item in queue"]
    pub free: *mut rt_uint8_t,
    #[doc = " Queue working mode: FIFO by default"]
    pub working_mode: rt_uint32_t,
    #[doc = " Queue for waiting to enqueue items in the working sysqueue"]
    pub enqueue_waiter: WaitQueue,
    #[doc = " Queue for waiting to dequeue items in the working sysqueue"]
    pub dequeue_waiter: WaitQueue,
    #[doc = " Spin lock for sysqueue"]
    pub spinlock: rt_spinlock,
}
#[test]
fn bindgen_test_layout_SysQueue() {
    const UNINIT: ::core::mem::MaybeUninit<SysQueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysQueue>(),
        76usize,
        concat!("Size of: ", stringify!(SysQueue))
    );
    assert_eq!(
        ::core::mem::align_of::<SysQueue>(),
        4usize,
        concat!("Alignment of ", stringify!(SysQueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(item_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_max_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(item_max_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).item_in_queue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(item_in_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue_buf) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(queue_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue_buf_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(queue_buf_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_storage_from_external) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(is_storage_from_external)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(read_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_pos) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(write_pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).head) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).working_mode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(working_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enqueue_waiter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(enqueue_waiter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dequeue_waiter) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(dequeue_waiter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SysQueue),
            "::",
            stringify!(spinlock)
        )
    );
}
#[doc = " Semaphore raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_semaphore {
    #[doc = " Inherit from KObject"]
    pub parent: rt_object,
    #[doc = " SysQueue for semaphore"]
    pub inner_queue: SysQueue,
}
#[test]
fn bindgen_test_layout_rt_semaphore() {
    const UNINIT: ::core::mem::MaybeUninit<rt_semaphore> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_semaphore>(),
        96usize,
        concat!("Size of: ", stringify!(rt_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_semaphore>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_semaphore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_queue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(inner_queue)
        )
    );
}
#[doc = " Condition variable raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_condvar {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " Spin lock"]
    pub spinlock: rt_spinlock,
    #[doc = " Inner semaphore condvar uses"]
    pub inner_sem: rt_semaphore,
}
#[test]
fn bindgen_test_layout_rt_condvar() {
    const UNINIT: ::core::mem::MaybeUninit<rt_condvar> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_condvar>(),
        120usize,
        concat!("Size of: ", stringify!(rt_condvar))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_condvar>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_condvar))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_condvar),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_condvar),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_sem) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_condvar),
            "::",
            stringify!(inner_sem)
        )
    );
}
#[doc = " Event flag raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_event {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " Event flog set value"]
    pub set: rt_uint32_t,
    #[doc = " SysQueue for Event flag"]
    pub inner_queue: SysQueue,
}
#[test]
fn bindgen_test_layout_rt_event() {
    const UNINIT: ::core::mem::MaybeUninit<rt_event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_event>(),
        100usize,
        concat!("Size of: ", stringify!(rt_event))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_event>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_queue) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(inner_queue)
        )
    );
}
pub type ThreadState = rt_uint8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadPriority {
    pub current: rt_uint8_t,
    pub initial: rt_uint8_t,
    pub number: rt_uint8_t,
    pub high_mask: rt_uint8_t,
    pub number_mask: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_ThreadPriority() {
    const UNINIT: ::core::mem::MaybeUninit<ThreadPriority> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ThreadPriority>(),
        8usize,
        concat!("Size of: ", stringify!(ThreadPriority))
    );
    assert_eq!(
        ::core::mem::align_of::<ThreadPriority>(),
        4usize,
        concat!("Alignment of ", stringify!(ThreadPriority))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadPriority),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initial) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadPriority),
            "::",
            stringify!(initial)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadPriority),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_mask) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadPriority),
            "::",
            stringify!(high_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ThreadPriority),
            "::",
            stringify!(number_mask)
        )
    );
}
#[doc = " Stack management structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_stack {
    #[doc = " Current stack pointer"]
    pub sp: *mut rt_size_t,
    #[doc = " Pointer to the lowest address of the stack"]
    pub bottom: *mut rt_uint8_t,
    #[doc = " Stack size"]
    pub size: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_stack() {
    const UNINIT: ::core::mem::MaybeUninit<rt_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_stack>(),
        12usize,
        concat!("Size of: ", stringify!(rt_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(size)
        )
    );
}
pub type ThreadCleanupFn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut rt_thread)>;
pub type TimerState = rt_uint8_t;
#[doc = " The timer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer {
    pub parent: rt_object,
    pub timeout_func: TimeoutFn,
    pub parameter: *mut core::ffi::c_void,
    pub init_tick: rt_uint32_t,
    pub timeout_tick: rt_uint32_t,
    pub flag: TimerState,
    pub list_node: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_timer() {
    const UNINIT: ::core::mem::MaybeUninit<rt_timer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_timer>(),
        48usize,
        concat!("Size of: ", stringify!(rt_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_timer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_func) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_tick) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_tick) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list_node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(list_node)
        )
    );
}
pub type Error = rt_int32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeSlice {
    pub init: rt_uint32_t,
    pub remaining: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_TimeSlice() {
    const UNINIT: ::core::mem::MaybeUninit<TimeSlice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TimeSlice>(),
        8usize,
        concat!("Size of: ", stringify!(TimeSlice))
    );
    assert_eq!(
        ::core::mem::align_of::<TimeSlice>(),
        4usize,
        concat!("Alignment of ", stringify!(TimeSlice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeSlice),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remaining) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeSlice),
            "::",
            stringify!(remaining)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MutexInfo {
    pub taken_list: rt_list_t,
    pub pending_to: *mut rt_mutex,
}
#[test]
fn bindgen_test_layout_MutexInfo() {
    const UNINIT: ::core::mem::MaybeUninit<MutexInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MutexInfo>(),
        12usize,
        concat!("Size of: ", stringify!(MutexInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<MutexInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(MutexInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MutexInfo),
            "::",
            stringify!(taken_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_to) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MutexInfo),
            "::",
            stringify!(pending_to)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EventInfo {
    pub set: rt_uint32_t,
    pub info: rt_uint8_t,
}
#[test]
fn bindgen_test_layout_EventInfo() {
    const UNINIT: ::core::mem::MaybeUninit<EventInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EventInfo>(),
        8usize,
        concat!("Size of: ", stringify!(EventInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<EventInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(EventInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EventInfo),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(EventInfo),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuAffinity {}
#[test]
fn bindgen_test_layout_CpuAffinity() {
    assert_eq!(
        ::core::mem::size_of::<CpuAffinity>(),
        0usize,
        concat!("Size of: ", stringify!(CpuAffinity))
    );
    assert_eq!(
        ::core::mem::align_of::<CpuAffinity>(),
        1usize,
        concat!("Alignment of ", stringify!(CpuAffinity))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LockInfo {}
#[test]
fn bindgen_test_layout_LockInfo() {
    assert_eq!(
        ::core::mem::size_of::<LockInfo>(),
        0usize,
        concat!("Size of: ", stringify!(LockInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<LockInfo>(),
        1usize,
        concat!("Alignment of ", stringify!(LockInfo))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_thread {
    pub parent: rt_object,
    pub tlist: rt_list_t,
    #[doc = " thread status"]
    pub stat: ThreadState,
    #[doc = " priority manager"]
    pub priority: ThreadPriority,
    #[doc = " stack point and cleanup func"]
    pub stack: rt_stack,
    pub cleanup: ThreadCleanupFn,
    pub tid: rt_size_t,
    #[doc = " built-in thread timer, used for wait timeout"]
    pub thread_timer: rt_timer,
    pub spinlock: rt_spinlock,
    #[doc = " error code"]
    pub error: Error,
    #[doc = " time slice"]
    pub time_slice: TimeSlice,
    pub mutex_info: MutexInfo,
    pub event_info: EventInfo,
}
#[test]
fn bindgen_test_layout_rt_thread() {
    const UNINIT: ::core::mem::MaybeUninit<rt_thread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_thread>(),
        144usize,
        concat!("Size of: ", stringify!(rt_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_thread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlist) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_timer) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(thread_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_slice) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(time_slice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex_info) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(mutex_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_info) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " Priority ceiling of mutex"]
    pub ceiling_priority: rt_uint8_t,
    #[doc = " Maximal priority for pending thread"]
    pub priority: rt_uint8_t,
    #[doc = " Current owner of mutex"]
    pub owner: *mut rt_thread,
    #[doc = " The object list taken by thread"]
    pub taken_node: rt_list_t,
    #[doc = " SysQueue for mutex"]
    pub inner_queue: SysQueue,
}
#[test]
fn bindgen_test_layout_rt_mutex() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mutex>(),
        112usize,
        concat!("Size of: ", stringify!(rt_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ceiling_priority) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(ceiling_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_node) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(taken_node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_queue) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(inner_queue)
        )
    );
}
#[doc = " RwLock Raw Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rwlock {
    pub parent: rt_object,
    #[doc = " Mutex that inner used for rwlock"]
    pub mutex: rt_mutex,
    #[doc = " Condition var for reader notification"]
    pub read_cond: rt_condvar,
    #[doc = " Condition var for writer notification"]
    pub write_cond: rt_condvar,
    #[doc = " Lock flag, which indicates >0 for readers occupied count, -1 for writer occupy"]
    pub rw_count: rt_int32_t,
    #[doc = " Readers wait for this condition var"]
    pub reader_waiting: rt_uint32_t,
    #[doc = " Writers ait for this condition var"]
    pub writer_waiting: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_rwlock() {
    const UNINIT: ::core::mem::MaybeUninit<rt_rwlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_rwlock>(),
        384usize,
        concat!("Size of: ", stringify!(rt_rwlock))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_rwlock>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_rwlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_cond) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write_cond) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rw_count) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(rw_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reader_waiting) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(reader_waiting)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writer_waiting) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rwlock),
            "::",
            stringify!(writer_waiting)
        )
    );
}
#[doc = " Mailbox raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mailbox {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " SysQueue for mailbox"]
    pub inner_queue: SysQueue,
}
#[test]
fn bindgen_test_layout_rt_mailbox() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mailbox> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mailbox>(),
        96usize,
        concat!("Size of: ", stringify!(rt_mailbox))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mailbox>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mailbox))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_queue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(inner_queue)
        )
    );
}
#[doc = " MessageQueue raw structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_messagequeue {
    #[doc = " Inherit from KObjectBase"]
    pub parent: rt_object,
    #[doc = " SysQueue for mailbox"]
    pub inner_queue: SysQueue,
}
#[test]
fn bindgen_test_layout_rt_messagequeue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_messagequeue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_messagequeue>(),
        96usize,
        concat!("Size of: ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_messagequeue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inner_queue) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(inner_queue)
        )
    );
}
pub type rt_object_t = *mut rt_object;
pub type rt_timer_t = *mut rt_timer;
pub const RT_INTERRUPTIBLE: _bindgen_ty_1 = 0;
pub const RT_KILLABLE: _bindgen_ty_1 = 1;
pub const RT_UNINTERRUPTIBLE: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_cpu {
    _unused: [u8; 0],
}
pub type rt_thread_cleanup_t = ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>;
pub type rt_thread_t = *mut rt_thread;
pub type rt_sem_t = *mut rt_semaphore;
pub type rt_mutex_t = *mut rt_mutex;
pub type rt_event_t = *mut rt_event;
pub type rt_mailbox_t = *mut rt_mailbox;
pub type rt_mq_t = *mut rt_messagequeue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memory {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< Memory management algorithm name"]
    pub algorithm: *const core::ffi::c_char,
    #[doc = "< memory start address"]
    pub address: rt_ubase_t,
    #[doc = "< memory size"]
    pub total: rt_size_t,
    #[doc = "< size used"]
    pub used: rt_size_t,
    #[doc = "< maximum usage"]
    pub max: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_memory() {
    const UNINIT: ::core::mem::MaybeUninit<rt_memory> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_memory>(),
        40usize,
        concat!("Size of: ", stringify!(rt_memory))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_memory>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_memory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(max)
        )
    );
}
pub type rt_mem_t = *mut rt_memory;
pub type rt_smem_t = rt_mem_t;
#[doc = "< character device"]
pub const rt_device_class_type_RT_Device_Class_Char: rt_device_class_type = 0;
#[doc = "< block device"]
pub const rt_device_class_type_RT_Device_Class_Block: rt_device_class_type = 1;
#[doc = "< net interface"]
pub const rt_device_class_type_RT_Device_Class_NetIf: rt_device_class_type = 2;
#[doc = "< memory device"]
pub const rt_device_class_type_RT_Device_Class_MTD: rt_device_class_type = 3;
#[doc = "< CAN device"]
pub const rt_device_class_type_RT_Device_Class_CAN: rt_device_class_type = 4;
#[doc = "< RTC device"]
pub const rt_device_class_type_RT_Device_Class_RTC: rt_device_class_type = 5;
#[doc = "< Sound device"]
pub const rt_device_class_type_RT_Device_Class_Sound: rt_device_class_type = 6;
#[doc = "< Graphic device"]
pub const rt_device_class_type_RT_Device_Class_Graphic: rt_device_class_type = 7;
#[doc = "< I2C bus device"]
pub const rt_device_class_type_RT_Device_Class_I2CBUS: rt_device_class_type = 8;
#[doc = "< USB slave device"]
pub const rt_device_class_type_RT_Device_Class_USBDevice: rt_device_class_type = 9;
#[doc = "< USB host bus"]
pub const rt_device_class_type_RT_Device_Class_USBHost: rt_device_class_type = 10;
#[doc = "< USB OTG bus"]
pub const rt_device_class_type_RT_Device_Class_USBOTG: rt_device_class_type = 11;
#[doc = "< SPI bus device"]
pub const rt_device_class_type_RT_Device_Class_SPIBUS: rt_device_class_type = 12;
#[doc = "< SPI device"]
pub const rt_device_class_type_RT_Device_Class_SPIDevice: rt_device_class_type = 13;
#[doc = "< SDIO bus device"]
pub const rt_device_class_type_RT_Device_Class_SDIO: rt_device_class_type = 14;
#[doc = "< PM pseudo device"]
pub const rt_device_class_type_RT_Device_Class_PM: rt_device_class_type = 15;
#[doc = "< Pipe device"]
pub const rt_device_class_type_RT_Device_Class_Pipe: rt_device_class_type = 16;
#[doc = "< Portal device"]
pub const rt_device_class_type_RT_Device_Class_Portal: rt_device_class_type = 17;
#[doc = "< Timer device"]
pub const rt_device_class_type_RT_Device_Class_Timer: rt_device_class_type = 18;
#[doc = "< Miscellaneous device"]
pub const rt_device_class_type_RT_Device_Class_Miscellaneous: rt_device_class_type = 19;
#[doc = "< Sensor device"]
pub const rt_device_class_type_RT_Device_Class_Sensor: rt_device_class_type = 20;
#[doc = "< Touch device"]
pub const rt_device_class_type_RT_Device_Class_Touch: rt_device_class_type = 21;
#[doc = "< PHY device"]
pub const rt_device_class_type_RT_Device_Class_PHY: rt_device_class_type = 22;
#[doc = "< Security device"]
pub const rt_device_class_type_RT_Device_Class_Security: rt_device_class_type = 23;
#[doc = "< WLAN device"]
pub const rt_device_class_type_RT_Device_Class_WLAN: rt_device_class_type = 24;
#[doc = "< Pin device"]
pub const rt_device_class_type_RT_Device_Class_Pin: rt_device_class_type = 25;
#[doc = "< ADC device"]
pub const rt_device_class_type_RT_Device_Class_ADC: rt_device_class_type = 26;
#[doc = "< DAC device"]
pub const rt_device_class_type_RT_Device_Class_DAC: rt_device_class_type = 27;
#[doc = "< WDT device"]
pub const rt_device_class_type_RT_Device_Class_WDT: rt_device_class_type = 28;
#[doc = "< PWM device"]
pub const rt_device_class_type_RT_Device_Class_PWM: rt_device_class_type = 29;
#[doc = "< Bus device"]
pub const rt_device_class_type_RT_Device_Class_Bus: rt_device_class_type = 30;
#[doc = "< unknown device"]
pub const rt_device_class_type_RT_Device_Class_Unknown: rt_device_class_type = 31;
#[doc = " device (I/O) class type"]
pub type rt_device_class_type = core::ffi::c_uchar;
pub type rt_device_t = *mut rt_device;
#[doc = " WaitQueue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue {
    pub flag: rt_uint32_t,
    pub waiting_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_wqueue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_wqueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_wqueue>(),
        12usize,
        concat!("Size of: ", stringify!(rt_wqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_wqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_wqueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waiting_list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(waiting_list)
        )
    );
}
#[doc = " WaitQueue structure"]
pub type rt_wqueue_t = rt_wqueue;
#[doc = " Device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< device type"]
    pub type_: rt_device_class_type,
    #[doc = "< device flag"]
    pub flag: rt_uint16_t,
    #[doc = "< device open flag"]
    pub open_flag: rt_uint16_t,
    #[doc = "< reference count"]
    pub ref_count: rt_uint8_t,
    #[doc = "< 0 - 255"]
    pub device_id: rt_uint8_t,
    pub rx_indicate:
        ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t>,
    pub tx_complete: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
    >,
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: core::ffi::c_int,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    #[doc = "< device private data"]
    pub user_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device>(),
        64usize,
        concat!("Size of: ", stringify!(rt_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_flag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_indicate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(rx_indicate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_complete) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(tx_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_id {
    pub compatible: *const core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device_id() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_id> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_id>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_id))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_id))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compatible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(compatible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_driver {
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: core::ffi::c_int,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    pub fops: *mut filesystem_ops,
    pub name: *const core::ffi::c_char,
    pub dev_type: rt_device_class_type,
    pub device_size: core::ffi::c_int,
    pub flag: core::ffi::c_int,
    pub dev_match: *const rt_device_id,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub probe_init:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub ops: *const core::ffi::c_void,
    pub drv_priv_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_driver() {
    const UNINIT: ::core::mem::MaybeUninit<rt_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_driver>(),
        68usize,
        concat!("Size of: ", stringify!(rt_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fops) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(device_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_match) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_init) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drv_priv_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(drv_priv_data)
        )
    );
}
pub type rt_driver_t = *mut rt_driver;
#[doc = " Notify structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_notify {
    pub notify: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t)>,
    pub dev: *mut rt_device,
}
#[test]
fn bindgen_test_layout_rt_device_notify() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_notify> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_notify>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_notify))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_notify>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_notify))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(dev)
        )
    );
}
#[doc = " block device geometry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_geometry {
    #[doc = "< count of sectors"]
    pub sector_count: rt_uint64_t,
    #[doc = "< number of bytes per sector"]
    pub bytes_per_sector: rt_uint32_t,
    #[doc = "< number of bytes to erase one block"]
    pub block_size: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_geometry() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_geometry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_geometry>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_geometry>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(sector_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_sector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(block_size)
        )
    );
}
#[doc = " sector arrange struct on block device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_sectors {
    #[doc = "< begin sector"]
    pub sector_begin: rt_uint64_t,
    #[doc = "< end sector"]
    pub sector_end: rt_uint64_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_sectors() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_sectors> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_sectors>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_sectors>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_end)
        )
    );
}
pub const RTGRAPHIC_PIXEL_FORMAT_MONO: _bindgen_ty_2 = 0;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY4: _bindgen_ty_2 = 1;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY16: _bindgen_ty_2 = 2;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB332: _bindgen_ty_2 = 3;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB444: _bindgen_ty_2 = 4;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565: _bindgen_ty_2 = 5;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565P: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR565: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB666: _bindgen_ty_2 = 7;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB888: _bindgen_ty_2 = 8;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR888: _bindgen_ty_2 = 9;
pub const RTGRAPHIC_PIXEL_FORMAT_ARGB888: _bindgen_ty_2 = 10;
pub const RTGRAPHIC_PIXEL_FORMAT_ABGR888: _bindgen_ty_2 = 11;
pub const RTGRAPHIC_PIXEL_FORMAT_RESERVED: _bindgen_ty_2 = 12;
pub type _bindgen_ty_2 = core::ffi::c_uchar;
#[doc = " graphic device information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_info {
    #[doc = "< graphic format"]
    pub pixel_format: rt_uint8_t,
    #[doc = "< bits per pixel"]
    pub bits_per_pixel: rt_uint8_t,
    #[doc = "< bytes per line"]
    pub pitch: rt_uint16_t,
    #[doc = "< width of graphic device"]
    pub width: rt_uint16_t,
    #[doc = "< height of graphic device"]
    pub height: rt_uint16_t,
    #[doc = "< frame buffer"]
    pub framebuffer: *mut rt_uint8_t,
    #[doc = "< allocated frame buffer size"]
    pub smem_len: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_info>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixel_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).framebuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smem_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(smem_len)
        )
    );
}
#[doc = " rectangle information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_rect_info {
    #[doc = "< x coordinate"]
    pub x: rt_uint16_t,
    #[doc = "< y coordinate"]
    pub y: rt_uint16_t,
    #[doc = "< width"]
    pub width: rt_uint16_t,
    #[doc = "< height"]
    pub height: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_device_rect_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_rect_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_rect_info>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_rect_info>(),
        2usize,
        concat!("Alignment of ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " graphic operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_ops {
    pub set_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *mut core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_hline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x1: core::ffi::c_int,
            x2: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_vline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y1: core::ffi::c_int,
            y2: core::ffi::c_int,
        ),
    >,
    pub blit_line: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
            size: rt_size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_ops> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_ops>(),
        20usize,
        concat!("Size of: ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_pixel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(set_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_hline) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_hline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_vline) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_vline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blit_line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(blit_line)
        )
    );
}
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_FLUSH: RT_HW_CACHE_OPS = 1;
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_INVALIDATE: RT_HW_CACHE_OPS = 2;
pub type RT_HW_CACHE_OPS = core::ffi::c_uchar;
extern "C" {
    pub fn rt_hw_cpu_reset();
}
extern "C" {
    pub fn rt_hw_cpu_shutdown();
}
extern "C" {
    pub fn rt_hw_cpu_arch() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn rt_hw_stack_init(
        entry: *mut core::ffi::c_void,
        parameter: *mut core::ffi::c_void,
        stack_addr: *mut rt_uint8_t,
        exit: *mut core::ffi::c_void,
    ) -> *mut rt_uint8_t;
}
pub type rt_isr_handler_t = ::core::option::Option<
    unsafe extern "C" fn(vector: core::ffi::c_int, param: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_irq_desc {
    pub handler: rt_isr_handler_t,
    pub param: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_irq_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_irq_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_irq_desc>(),
        8usize,
        concat!("Size of: ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_irq_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(param)
        )
    );
}
extern "C" {
    pub fn rt_hw_interrupt_init();
}
extern "C" {
    pub fn rt_hw_interrupt_mask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_umask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_install(
        vector: core::ffi::c_int,
        handler: rt_isr_handler_t,
        param: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> rt_isr_handler_t;
}
extern "C" {
    pub fn rt_hw_interrupt_disable() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_interrupt_enable(level: rt_base_t);
}
extern "C" {
    pub fn rt_hw_interrupt_is_disabled() -> rt_bool_t;
}
extern "C" {
    pub fn rt_sched_unlock(level: rt_base_t);
}
extern "C" {
    pub fn rt_sched_lock() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_context_switch(from: rt_ubase_t, to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_to(to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_interrupt(
        context: *mut core::ffi::c_void,
        from: rt_ubase_t,
        to: rt_ubase_t,
        to_thread: *mut rt_thread,
    );
}
extern "C" {
    pub fn rt_hw_console_output(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_hw_backtrace(fp: *mut rt_uint32_t, thread_entry: rt_ubase_t);
}
extern "C" {
    pub fn rt_hw_show_memory(addr: rt_uint32_t, size: rt_size_t);
}
extern "C" {
    pub fn rt_hw_exception_install(
        exception_handle: ::core::option::Option<
            unsafe extern "C" fn(context: *mut core::ffi::c_void) -> rt_err_t,
        >,
    );
}
extern "C" {
    pub fn rt_hw_us_delay(us: rt_uint32_t);
}
extern "C" {
    pub fn rt_hw_cpu_id() -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_hw_atomic_load(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_store(ptr: *mut rt_atomic_t, val: rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_add(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_sub(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_and(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_or(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_xor(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_exchange(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_flag_clear(ptr: *mut rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_flag_test_and_set(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_compare_exchange_strong(
        ptr: *mut rt_atomic_t,
        expected: *mut rt_atomic_t,
        desired: rt_atomic_t,
    ) -> rt_atomic_t;
}
pub type syscall_func = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall {
    pub name: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub opt: *mut msh_cmd_opt,
    pub func: syscall_func,
}
#[test]
fn bindgen_test_layout_finsh_syscall() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall>(),
        16usize,
        concat!("Size of: ", stringify!(finsh_syscall))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall_item {
    pub next: *mut finsh_syscall_item,
    pub syscall: finsh_syscall,
}
#[test]
fn bindgen_test_layout_finsh_syscall_item() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall_item>(),
        20usize,
        concat!("Size of: ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall_item>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syscall) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(syscall)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msh_cmd_opt {
    pub id: rt_uint32_t,
    pub name: *const core::ffi::c_char,
    pub des: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_msh_cmd_opt() {
    const UNINIT: ::core::mem::MaybeUninit<msh_cmd_opt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<msh_cmd_opt>(),
        12usize,
        concat!("Size of: ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        ::core::mem::align_of::<msh_cmd_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(des)
        )
    );
}
pub type msh_cmd_opt_t = msh_cmd_opt;
extern "C" {
    pub fn msh_opt_list_dump(options: *mut core::ffi::c_void);
}
extern "C" {
    pub fn msh_cmd_opt_id_get(
        argc: core::ffi::c_int,
        argv: *mut *mut core::ffi::c_char,
        options: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut global_syscall_list: *mut finsh_syscall_item;
}
extern "C" {
    pub static mut _syscall_table_begin: *mut finsh_syscall;
}
extern "C" {
    pub static mut _syscall_table_end: *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_syscall_lookup(name: *const core::ffi::c_char) -> *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_set_device(device_name: *const core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object_information {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " @addtogroup KernelObject\n @{"]
    pub fn rt_object_get_information(type_: rt_object_class_type) -> *mut rt_object_information;
}
extern "C" {
    pub fn rt_object_get_length(type_: rt_object_class_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_get_pointers(
        type_: rt_object_class_type,
        pointers: *mut rt_object_t,
        maxlen: rt_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_init(
        object: *mut rt_object,
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn rt_object_detach(object: rt_object_t);
}
extern "C" {
    pub fn rt_object_allocate(
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_delete(object: rt_object_t);
}
extern "C" {
    pub fn rt_custom_object_create(
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        data_destroy: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_custom_object_destroy(obj: rt_object_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_object_is_systemobject(object: rt_object_t) -> rt_bool_t;
}
extern "C" {
    pub fn rt_object_get_type(object: rt_object_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_object_find(name: *const core::ffi::c_char, type_: rt_uint8_t) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_get_name(
        object: rt_object_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    #[doc = " @addtogroup Clock\n @{"]
    pub fn rt_tick_get() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_set(tick: rt_tick_t);
}
extern "C" {
    pub fn rt_tick_increase();
}
extern "C" {
    pub fn rt_tick_from_millisecond(ms: rt_int32_t) -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_get_millisecond() -> rt_tick_t;
}
extern "C" {
    pub fn rt_system_timer_init();
}
extern "C" {
    pub fn rt_system_timer_thread_init();
}
extern "C" {
    pub fn rt_timer_init(
        timer: rt_timer_t,
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    );
}
extern "C" {
    pub fn rt_timer_detach(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_create(
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    ) -> rt_timer_t;
}
extern "C" {
    pub fn rt_timer_delete(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_start(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_stop(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_control(
        timer: rt_timer_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_next_timeout_tick() -> rt_tick_t;
}
extern "C" {
    pub fn rt_timer_check();
}
extern "C" {
    #[doc = " @addtogroup Thread\n @{"]
    pub fn rt_thread_init(
        thread: *mut rt_thread,
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_start: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_detach(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_create(
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_delete(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_self() -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_find(name: *mut core::ffi::c_char) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_startup(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_yield() -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delay(tick: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_mdelay(ms: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_control(
        thread: rt_thread_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend_with_flag(thread: rt_thread_t, suspend_flag: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_resume(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_timeout(parameter: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_thread_get_name(
        thread: rt_thread_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_init();
}
extern "C" {
    pub fn rt_thread_idle_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_delhook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_gethandler() -> rt_thread_t;
}
extern "C" {
    pub fn rt_system_scheduler_init();
}
extern "C" {
    pub fn rt_system_scheduler_start();
}
extern "C" {
    pub fn rt_schedule();
}
extern "C" {
    pub fn rt_schedule_insert_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_schedule_remove_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_enter_critical();
}
extern "C" {
    pub fn rt_exit_critical();
}
extern "C" {
    pub fn rt_critical_level() -> rt_uint16_t;
}
extern "C" {
    pub fn rt_system_heap_init(
        begin_addr: *mut core::ffi::c_void,
        end_addr: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rt_malloc(size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_realloc(ptr: *mut core::ffi::c_void, newsize: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_calloc(count: rt_size_t, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_malloc_align(size: rt_size_t, align: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free_align(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_memory_info(total: *mut rt_size_t, used: *mut rt_size_t, max_used: *mut rt_size_t);
}
extern "C" {
    #[doc = " small memory object interface"]
    pub fn rt_smem_init(
        name: *const core::ffi::c_char,
        begin_addr: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_smem_t;
}
extern "C" {
    pub fn rt_smem_detach(m: rt_smem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_smem_alloc(m: rt_smem_t, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_smem_realloc(
        m: rt_smem_t,
        rmem: *mut core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_smem_free(rmem: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_sem_init(
        sem: rt_sem_t,
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_detach(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_create(
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_sem_t;
}
extern "C" {
    pub fn rt_sem_delete(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_interruptible(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_killable(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_trytake(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_release(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_control(
        sem: rt_sem_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_init(
        mutex: rt_mutex_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_detach(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_mutex_t;
}
extern "C" {
    pub fn rt_mutex_delete(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_drop_thread(mutex: rt_mutex_t, thread: rt_thread_t);
}
extern "C" {
    pub fn rt_mutex_setprioceiling(mutex: rt_mutex_t, priority: rt_uint8_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_getprioceiling(mutex: rt_mutex_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_take(mutex: rt_mutex_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_trytake(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_interruptible(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_killable(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_release(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_control(
        mutex: rt_mutex_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_init(
        rwlock: *mut rt_rwlock,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_detach(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_lock_read(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_lock_write(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_try_lock_read(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_try_lock_write(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_rwlock_unlock(rwlock: *mut rt_rwlock) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_init(
        event: rt_event_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_detach(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_event_t;
}
extern "C" {
    pub fn rt_event_delete(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_send(event: rt_event_t, set: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_interruptible(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_killable(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_control(
        event: rt_event_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_condvar_init(
        condvar: *mut rt_condvar,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_condvar_detach(condvar: *mut rt_condvar) -> rt_err_t;
}
extern "C" {
    pub fn rt_condvar_wait(condvar: *mut rt_condvar, mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_condvar_notify(arg1: *mut rt_condvar) -> rt_err_t;
}
extern "C" {
    pub fn rt_condvar_notify_all(condvar: *mut rt_condvar) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_init(
        mb: rt_mailbox_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_detach(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_create(
        name: *const core::ffi::c_char,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mailbox_t;
}
extern "C" {
    pub fn rt_mb_delete(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait(mb: rt_mailbox_t, value: rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_interruptible(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_killable(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_urgent(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv(mb: rt_mailbox_t, value: *mut rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_interruptible(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_killable(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_control(
        mb: rt_mailbox_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mq_message {
    pub next: *mut rt_mq_message,
    pub length: rt_ssize_t,
}
#[test]
fn bindgen_test_layout_rt_mq_message() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mq_message> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mq_message>(),
        8usize,
        concat!("Size of: ", stringify!(rt_mq_message))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mq_message>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mq_message))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    pub fn rt_mq_init(
        mq: rt_mq_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        msg_size: rt_size_t,
        pool_size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_detach(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_create(
        name: *const core::ffi::c_char,
        msg_size: rt_size_t,
        max_msgs: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mq_t;
}
extern "C" {
    pub fn rt_mq_delete(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_entry(mq: rt_mq_t) -> rt_uint16_t;
}
extern "C" {
    pub fn rt_mq_send(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_urgent(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_interruptible(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_killable(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_control(
        mq: rt_mq_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_defunct_enqueue(thread: rt_thread_t);
}
extern "C" {
    pub fn rt_thread_defunct_dequeue() -> rt_thread_t;
}
extern "C" {
    pub fn rt_spin_lock_init(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_unlock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock_irqsave(lock: *mut rt_spinlock) -> rt_base_t;
}
extern "C" {
    pub fn rt_spin_unlock_irqrestore(lock: *mut rt_spinlock, level: rt_base_t);
}
extern "C" {
    #[doc = " @addtogroup Device\n @{"]
    pub fn rt_device_find(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_register(
        dev: rt_device_t,
        name: *const core::ffi::c_char,
        flags: rt_uint16_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_unregister(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_create(type_: core::ffi::c_int, attach_size: core::ffi::c_int) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_destroy(device: rt_device_t);
}
extern "C" {
    pub fn rt_device_set_rx_indicate(
        dev: rt_device_t,
        rx_ind: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_set_tx_complete(
        dev: rt_device_t,
        tx_done: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_init(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_open(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_close(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_read(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_write(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_control(
        dev: rt_device_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_interrupt_enter();
}
extern "C" {
    pub fn rt_interrupt_leave();
}
extern "C" {
    pub fn rt_interrupt_get_nest() -> rt_uint8_t;
}
extern "C" {
    pub fn rt_components_init();
}
extern "C" {
    pub fn rt_components_board_init();
}
extern "C" {
    pub fn rt_kprintf(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_kputs(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_vsprintf(
        dest: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        arg_ptr: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_vsnprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_sprintf(
        buf: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_snprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_console_set_device(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_console_get_device() -> rt_device_t;
}
extern "C" {
    pub fn rt_get_errno() -> rt_err_t;
}
extern "C" {
    pub fn rt_set_errno(no: rt_err_t);
}
extern "C" {
    pub fn _rt_errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn rt_strerror(error: rt_err_t) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn __rt_ffs(value: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_memset(
        src: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcpy(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcmp(
        cs: *const core::ffi::c_void,
        ct: *const core::ffi::c_void,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strdup(s: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strnlen(s: *const core::ffi::c_char, maxlen: rt_ubase_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_strstr(
        str1: *const core::ffi::c_char,
        str2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strcasecmp(a: *const core::ffi::c_char, b: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcpy(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncpy(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        n: rt_size_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncmp(
        cs: *const core::ffi::c_char,
        ct: *const core::ffi::c_char,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcmp(cs: *const core::ffi::c_char, ct: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strlen(src: *const core::ffi::c_char) -> rt_size_t;
}
extern "C" {
    pub fn rt_show_version();
}
extern "C" {
    pub static mut rt_assert_hook: ::core::option::Option<
        unsafe extern "C" fn(
            ex: *const core::ffi::c_char,
            func: *const core::ffi::c_char,
            line: rt_size_t,
        ),
    >;
}
extern "C" {
    pub fn rt_assert_set_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(
                ex: *const core::ffi::c_char,
                func: *const core::ffi::c_char,
                line: rt_size_t,
            ),
        >,
    );
}
extern "C" {
    pub fn rt_assert_handler(
        ex: *const core::ffi::c_char,
        func: *const core::ffi::c_char,
        line: rt_size_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_ringbuffer {
    pub buffer_ptr: *mut rt_uint8_t,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub buffer_size: rt_int32_t,
}
#[test]
fn bindgen_test_layout_rt_ringbuffer() {
    const UNINIT: ::core::mem::MaybeUninit<rt_ringbuffer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_ringbuffer>(),
        16usize,
        concat!("Size of: ", stringify!(rt_ringbuffer))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_ringbuffer>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_ringbuffer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ringbuffer),
            "::",
            stringify!(buffer_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ringbuffer),
            "::",
            stringify!(buffer_size)
        )
    );
}
impl rt_ringbuffer {
    #[inline]
    pub fn read_mirror(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_read_mirror(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_index(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_read_index(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn write_mirror(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_write_mirror(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_index(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_write_index(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_mirror: rt_uint32_t,
        read_index: rt_uint32_t,
        write_mirror: rt_uint32_t,
        write_index: rt_uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_mirror: u32 = unsafe { ::core::mem::transmute(read_mirror) };
            read_mirror as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let read_index: u32 = unsafe { ::core::mem::transmute(read_index) };
            read_index as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let write_mirror: u32 = unsafe { ::core::mem::transmute(write_mirror) };
            write_mirror as u64
        });
        __bindgen_bitfield_unit.set(33usize, 31u8, {
            let write_index: u32 = unsafe { ::core::mem::transmute(write_index) };
            write_index as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const rt_ringbuffer_state_RT_RINGBUFFER_EMPTY: rt_ringbuffer_state = 0;
pub const rt_ringbuffer_state_RT_RINGBUFFER_FULL: rt_ringbuffer_state = 1;
pub const rt_ringbuffer_state_RT_RINGBUFFER_HALFFULL: rt_ringbuffer_state = 2;
pub type rt_ringbuffer_state = core::ffi::c_uchar;
extern "C" {
    #[doc = " RingBuffer for DeviceDriver\n\n Please note that the ring buffer implementation of RT-Thread\n has no thread wait or resume feature."]
    pub fn rt_ringbuffer_init(rb: *mut rt_ringbuffer, pool: *mut rt_uint8_t, size: rt_int32_t);
}
extern "C" {
    pub fn rt_ringbuffer_reset(rb: *mut rt_ringbuffer);
}
extern "C" {
    pub fn rt_ringbuffer_put(
        rb: *mut rt_ringbuffer,
        ptr: *const rt_uint8_t,
        length: rt_uint32_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_put_force(
        rb: *mut rt_ringbuffer,
        ptr: *const rt_uint8_t,
        length: rt_uint32_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_putchar(rb: *mut rt_ringbuffer, ch: rt_uint8_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_putchar_force(rb: *mut rt_ringbuffer, ch: rt_uint8_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_get(
        rb: *mut rt_ringbuffer,
        ptr: *mut rt_uint8_t,
        length: rt_uint32_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_peek(rb: *mut rt_ringbuffer, ptr: *mut *mut rt_uint8_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_getchar(rb: *mut rt_ringbuffer, ch: *mut rt_uint8_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_data_len(rb: *mut rt_ringbuffer) -> rt_size_t;
}
extern "C" {
    pub fn rt_ringbuffer_create(length: rt_uint32_t) -> *mut rt_ringbuffer;
}
extern "C" {
    pub fn rt_ringbuffer_destroy(rb: *mut rt_ringbuffer);
}
#[doc = " Completion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_completion {
    pub flag: rt_uint32_t,
    pub suspended_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_completion() {
    const UNINIT: ::core::mem::MaybeUninit<rt_completion> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_completion>(),
        12usize,
        concat!("Size of: ", stringify!(rt_completion))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_completion>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_completion))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_completion),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspended_list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_completion),
            "::",
            stringify!(suspended_list)
        )
    );
}
extern "C" {
    pub fn rt_completion_init(completion: *mut rt_completion);
}
extern "C" {
    pub fn rt_completion_wait(completion: *mut rt_completion, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_completion_done(completion: *mut rt_completion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_data_item {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_data_queue {
    pub magic: rt_uint32_t,
    pub size: rt_uint16_t,
    pub lwm: rt_uint16_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub queue: *mut rt_data_item,
    pub suspended_push_list: rt_list_t,
    pub suspended_pop_list: rt_list_t,
    pub evt_notify:
        ::core::option::Option<unsafe extern "C" fn(queue: *mut rt_data_queue, event: rt_uint32_t)>,
}
#[test]
fn bindgen_test_layout_rt_data_queue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_data_queue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_data_queue>(),
        36usize,
        concat!("Size of: ", stringify!(rt_data_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_data_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_data_queue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lwm) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(lwm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).queue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspended_push_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(suspended_push_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspended_pop_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(suspended_pop_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).evt_notify) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_data_queue),
            "::",
            stringify!(evt_notify)
        )
    );
}
impl rt_data_queue {
    #[inline]
    pub fn get_index(&self) -> rt_uint16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_get_index(&mut self, val: rt_uint16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn is_empty(&self) -> rt_uint16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_empty(&mut self, val: rt_uint16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn put_index(&self) -> rt_uint16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_put_index(&mut self, val: rt_uint16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn is_full(&self) -> rt_uint16_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_is_full(&mut self, val: rt_uint16_t) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        get_index: rt_uint16_t,
        is_empty: rt_uint16_t,
        put_index: rt_uint16_t,
        is_full: rt_uint16_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let get_index: u16 = unsafe { ::core::mem::transmute(get_index) };
            get_index as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let is_empty: u16 = unsafe { ::core::mem::transmute(is_empty) };
            is_empty as u64
        });
        __bindgen_bitfield_unit.set(16usize, 15u8, {
            let put_index: u16 = unsafe { ::core::mem::transmute(put_index) };
            put_index as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_full: u16 = unsafe { ::core::mem::transmute(is_full) };
            is_full as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[doc = " DataQueue for DeviceDriver"]
    pub fn rt_data_queue_init(
        queue: *mut rt_data_queue,
        size: rt_uint16_t,
        lwm: rt_uint16_t,
        evt_notify: ::core::option::Option<
            unsafe extern "C" fn(queue: *mut rt_data_queue, event: rt_uint32_t),
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_data_queue_push(
        queue: *mut rt_data_queue,
        data_ptr: *const core::ffi::c_void,
        data_size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_data_queue_pop(
        queue: *mut rt_data_queue,
        data_ptr: *mut *const core::ffi::c_void,
        size: *mut rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_data_queue_peek(
        queue: *mut rt_data_queue,
        data_ptr: *mut *const core::ffi::c_void,
        size: *mut rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_data_queue_reset(queue: *mut rt_data_queue);
}
extern "C" {
    pub fn rt_data_queue_deinit(queue: *mut rt_data_queue) -> rt_err_t;
}
extern "C" {
    pub fn rt_data_queue_len(queue: *mut rt_data_queue) -> rt_uint16_t;
}
pub const RT_WORK_STATE_PENDING: _bindgen_ty_3 = 1;
pub const RT_WORK_STATE_SUBMITTING: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = core::ffi::c_uchar;
pub const RT_WORK_TYPE_DELAYED: _bindgen_ty_4 = 1;
#[doc = " work type definitions"]
pub type _bindgen_ty_4 = core::ffi::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_workqueue {
    pub work_list: rt_list_t,
    pub delayed_list: rt_list_t,
    pub work_current: *mut rt_work,
    pub sem: rt_semaphore,
    pub work_thread: rt_thread_t,
}
#[test]
fn bindgen_test_layout_rt_workqueue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_workqueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_workqueue>(),
        120usize,
        concat!("Size of: ", stringify!(rt_workqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_workqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_workqueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delayed_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(delayed_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_thread) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_work {
    pub list: rt_list_t,
    pub work_func: ::core::option::Option<
        unsafe extern "C" fn(work: *mut rt_work, work_data: *mut core::ffi::c_void),
    >,
    pub work_data: *mut core::ffi::c_void,
    pub flags: rt_uint16_t,
    pub type_: rt_uint16_t,
    pub timer: rt_timer,
    pub workqueue: *mut rt_workqueue,
}
#[test]
fn bindgen_test_layout_rt_work() {
    const UNINIT: ::core::mem::MaybeUninit<rt_work> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_work>(),
        72usize,
        concat!("Size of: ", stringify!(rt_work))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_work>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_work))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(work_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(work_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).workqueue) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(workqueue)
        )
    );
}
extern "C" {
    #[doc = " WorkQueue for DeviceDriver"]
    pub fn rt_work_init(
        work: *mut rt_work,
        work_func: ::core::option::Option<
            unsafe extern "C" fn(work: *mut rt_work, work_data: *mut core::ffi::c_void),
        >,
        work_data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rt_workqueue_create(
        name: *const core::ffi::c_char,
        stack_size: rt_uint16_t,
        priority: rt_uint8_t,
    ) -> *mut rt_workqueue;
}
extern "C" {
    pub fn rt_workqueue_destroy(queue: *mut rt_workqueue) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_dowork(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_submit_work(
        queue: *mut rt_workqueue,
        work: *mut rt_work,
        ticks: rt_tick_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_work(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_work_sync(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_all_work(queue: *mut rt_workqueue) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_urgent_work(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
pub type rt_wqueue_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        wait: *mut rt_wqueue_node,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue_node {
    pub polling_thread: rt_thread_t,
    pub list: rt_list_t,
    pub wakeup: rt_wqueue_func_t,
    pub key: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_wqueue_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_wqueue_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_wqueue_node>(),
        20usize,
        concat!("Size of: ", stringify!(rt_wqueue_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_wqueue_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_wqueue_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).polling_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue_node),
            "::",
            stringify!(polling_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue_node),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wakeup) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue_node),
            "::",
            stringify!(wakeup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue_node),
            "::",
            stringify!(key)
        )
    );
}
pub type rt_wqueue_node_t = rt_wqueue_node;
extern "C" {
    pub fn __wqueue_default_wake(
        wait: *mut rt_wqueue_node,
        key: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_wqueue_add(queue: *mut rt_wqueue_t, node: *mut rt_wqueue_node);
}
extern "C" {
    pub fn rt_wqueue_remove(node: *mut rt_wqueue_node);
}
extern "C" {
    pub fn rt_wqueue_wait(
        queue: *mut rt_wqueue_t,
        condition: core::ffi::c_int,
        timeout: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_wqueue_wait_killable(
        queue: *mut rt_wqueue_t,
        condition: core::ffi::c_int,
        timeout: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_wqueue_wait_interruptible(
        queue: *mut rt_wqueue_t,
        condition: core::ffi::c_int,
        timeout: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_wqueue_wakeup(queue: *mut rt_wqueue_t, key: *mut core::ffi::c_void);
}
#[doc = " Pipe Device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_pipe_device {
    pub parent: rt_device,
    pub is_named: rt_bool_t,
    pub fifo: *mut rt_ringbuffer,
    pub bufsz: rt_uint16_t,
    pub reader_queue: rt_wqueue_t,
    pub writer_queue: rt_wqueue_t,
    pub writer: core::ffi::c_int,
    pub reader: core::ffi::c_int,
    pub lock: rt_mutex,
}
#[test]
fn bindgen_test_layout_rt_pipe_device() {
    const UNINIT: ::core::mem::MaybeUninit<rt_pipe_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_pipe_device>(),
        220usize,
        concat!("Size of: ", stringify!(rt_pipe_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_pipe_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_pipe_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_named) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(is_named)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fifo) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(fifo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufsz) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(bufsz)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reader_queue) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(reader_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writer_queue) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(writer_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).writer) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reader) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(reader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pipe_device),
            "::",
            stringify!(lock)
        )
    );
}
#[doc = " Pipe Device"]
pub type rt_pipe_t = rt_pipe_device;
extern "C" {
    pub fn rt_pipe_create(
        name: *const core::ffi::c_char,
        bufsz: core::ffi::c_int,
    ) -> *mut rt_pipe_t;
}
extern "C" {
    pub fn rt_pipe_delete(name: *const core::ffi::c_char) -> core::ffi::c_int;
}
pub type poll_queue_proc =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut rt_wqueue_t, arg2: *mut rt_pollreq)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_pollreq {
    pub _proc: poll_queue_proc,
    pub _key: core::ffi::c_short,
}
#[test]
fn bindgen_test_layout_rt_pollreq() {
    const UNINIT: ::core::mem::MaybeUninit<rt_pollreq> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_pollreq>(),
        8usize,
        concat!("Size of: ", stringify!(rt_pollreq))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_pollreq>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_pollreq))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._proc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pollreq),
            "::",
            stringify!(_proc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pollreq),
            "::",
            stringify!(_key)
        )
    );
}
pub type rt_pollreq_t = rt_pollreq;
pub const rt_rbb_status_RT_RBB_BLK_UNUSED: rt_rbb_status = 0;
pub const rt_rbb_status_RT_RBB_BLK_INITED: rt_rbb_status = 1;
pub const rt_rbb_status_RT_RBB_BLK_PUT: rt_rbb_status = 2;
pub const rt_rbb_status_RT_RBB_BLK_GET: rt_rbb_status = 3;
pub type rt_rbb_status = core::ffi::c_uchar;
pub use self::rt_rbb_status as rt_rbb_status_t;
#[doc = " the block of rbb"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rbb_blk {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub buf: *mut rt_uint8_t,
    pub list: rt_slist_t,
}
#[test]
fn bindgen_test_layout_rt_rbb_blk() {
    const UNINIT: ::core::mem::MaybeUninit<rt_rbb_blk> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_rbb_blk>(),
        12usize,
        concat!("Size of: ", stringify!(rt_rbb_blk))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_rbb_blk>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_rbb_blk))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb_blk),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb_blk),
            "::",
            stringify!(list)
        )
    );
}
impl rt_rbb_blk {
    #[inline]
    pub fn status(&self) -> rt_rbb_status_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_status(&mut self, val: rt_rbb_status_t) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> rt_size_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: rt_size_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: rt_rbb_status_t,
        size: rt_size_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let status: u8 = unsafe { ::core::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(8usize, 24u8, {
            let size: u32 = unsafe { ::core::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rt_rbb_blk_t = *mut rt_rbb_blk;
#[doc = " Rbb block queue: the blocks (from block1->buf to blockn->buf) memory which on this queue is continuous."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rbb_blk_queue {
    pub blocks: rt_rbb_blk_t,
    pub blk_num: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_rbb_blk_queue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_rbb_blk_queue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_rbb_blk_queue>(),
        8usize,
        concat!("Size of: ", stringify!(rt_rbb_blk_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_rbb_blk_queue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_rbb_blk_queue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blocks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb_blk_queue),
            "::",
            stringify!(blocks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk_num) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb_blk_queue),
            "::",
            stringify!(blk_num)
        )
    );
}
pub type rt_rbb_blk_queue_t = *mut rt_rbb_blk_queue;
#[doc = " ring block buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_rbb {
    pub buf: *mut rt_uint8_t,
    pub buf_size: rt_size_t,
    pub blk_set: rt_rbb_blk_t,
    pub blk_max_num: rt_size_t,
    pub blk_list: rt_slist_t,
    pub tail: *mut rt_slist_t,
    pub free_list: rt_slist_t,
}
#[test]
fn bindgen_test_layout_rt_rbb() {
    const UNINIT: ::core::mem::MaybeUninit<rt_rbb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_rbb>(),
        28usize,
        concat!("Size of: ", stringify!(rt_rbb))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_rbb>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_rbb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk_set) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(blk_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk_max_num) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(blk_max_num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blk_list) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(blk_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_rbb),
            "::",
            stringify!(free_list)
        )
    );
}
pub type rt_rbb_t = *mut rt_rbb;
extern "C" {
    pub fn rt_rbb_init(
        rbb: rt_rbb_t,
        buf: *mut rt_uint8_t,
        buf_size: rt_size_t,
        block_set: rt_rbb_blk_t,
        blk_max_num: rt_size_t,
    );
}
extern "C" {
    pub fn rt_rbb_get_buf_size(rbb: rt_rbb_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_rbb_create(buf_size: rt_size_t, blk_max_num: rt_size_t) -> rt_rbb_t;
}
extern "C" {
    pub fn rt_rbb_destroy(rbb: rt_rbb_t);
}
extern "C" {
    pub fn rt_rbb_blk_alloc(rbb: rt_rbb_t, blk_size: rt_size_t) -> rt_rbb_blk_t;
}
extern "C" {
    pub fn rt_rbb_blk_put(block: rt_rbb_blk_t);
}
extern "C" {
    pub fn rt_rbb_blk_get(rbb: rt_rbb_t) -> rt_rbb_blk_t;
}
extern "C" {
    pub fn rt_rbb_blk_size(block: rt_rbb_blk_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_rbb_blk_buf(block: rt_rbb_blk_t) -> *mut rt_uint8_t;
}
extern "C" {
    pub fn rt_rbb_blk_free(rbb: rt_rbb_t, block: rt_rbb_blk_t);
}
extern "C" {
    pub fn rt_rbb_blk_queue_get(
        rbb: rt_rbb_t,
        queue_data_len: rt_size_t,
        blk_queue: rt_rbb_blk_queue_t,
    ) -> rt_size_t;
}
extern "C" {
    pub fn rt_rbb_blk_queue_len(blk_queue: rt_rbb_blk_queue_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_rbb_blk_queue_buf(blk_queue: rt_rbb_blk_queue_t) -> *mut rt_uint8_t;
}
extern "C" {
    pub fn rt_rbb_blk_queue_free(rbb: rt_rbb_t, blk_queue: rt_rbb_blk_queue_t);
}
extern "C" {
    pub fn rt_rbb_next_blk_queue_len(rbb: rt_rbb_t) -> rt_size_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct serial_configure {
    pub baud_rate: rt_uint32_t,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_serial_configure() {
    const UNINIT: ::core::mem::MaybeUninit<serial_configure> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<serial_configure>(),
        8usize,
        concat!("Size of: ", stringify!(serial_configure))
    );
    assert_eq!(
        ::core::mem::align_of::<serial_configure>(),
        4usize,
        concat!("Alignment of ", stringify!(serial_configure))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baud_rate) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(serial_configure),
            "::",
            stringify!(baud_rate)
        )
    );
}
impl serial_configure {
    #[inline]
    pub fn data_bits(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_data_bits(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn stop_bits(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_stop_bits(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn parity(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_parity(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn bit_order(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_bit_order(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn invert(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_invert(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bufsz(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_bufsz(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn flowcontrol(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_flowcontrol(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> rt_uint32_t {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: rt_uint32_t) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        data_bits: rt_uint32_t,
        stop_bits: rt_uint32_t,
        parity: rt_uint32_t,
        bit_order: rt_uint32_t,
        invert: rt_uint32_t,
        bufsz: rt_uint32_t,
        flowcontrol: rt_uint32_t,
        reserved: rt_uint32_t,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let data_bits: u32 = unsafe { ::core::mem::transmute(data_bits) };
            data_bits as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let stop_bits: u32 = unsafe { ::core::mem::transmute(stop_bits) };
            stop_bits as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let parity: u32 = unsafe { ::core::mem::transmute(parity) };
            parity as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let bit_order: u32 = unsafe { ::core::mem::transmute(bit_order) };
            bit_order as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let invert: u32 = unsafe { ::core::mem::transmute(invert) };
            invert as u64
        });
        __bindgen_bitfield_unit.set(10usize, 16u8, {
            let bufsz: u32 = unsafe { ::core::mem::transmute(bufsz) };
            bufsz as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let flowcontrol: u32 = unsafe { ::core::mem::transmute(flowcontrol) };
            flowcontrol as u64
        });
        __bindgen_bitfield_unit.set(27usize, 5u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_serial_rx_fifo {
    pub buffer: *mut rt_uint8_t,
    pub put_index: rt_uint16_t,
    pub get_index: rt_uint16_t,
    pub is_full: rt_bool_t,
}
#[test]
fn bindgen_test_layout_rt_serial_rx_fifo() {
    const UNINIT: ::core::mem::MaybeUninit<rt_serial_rx_fifo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_serial_rx_fifo>(),
        12usize,
        concat!("Size of: ", stringify!(rt_serial_rx_fifo))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_serial_rx_fifo>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_serial_rx_fifo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_rx_fifo),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).put_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_rx_fifo),
            "::",
            stringify!(put_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_index) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_rx_fifo),
            "::",
            stringify!(get_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_full) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_rx_fifo),
            "::",
            stringify!(is_full)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_serial_tx_fifo {
    pub completion: rt_completion,
}
#[test]
fn bindgen_test_layout_rt_serial_tx_fifo() {
    const UNINIT: ::core::mem::MaybeUninit<rt_serial_tx_fifo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_serial_tx_fifo>(),
        12usize,
        concat!("Size of: ", stringify!(rt_serial_tx_fifo))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_serial_tx_fifo>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_serial_tx_fifo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).completion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_tx_fifo),
            "::",
            stringify!(completion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_serial_rx_dma {
    pub activated: rt_bool_t,
}
#[test]
fn bindgen_test_layout_rt_serial_rx_dma() {
    const UNINIT: ::core::mem::MaybeUninit<rt_serial_rx_dma> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_serial_rx_dma>(),
        4usize,
        concat!("Size of: ", stringify!(rt_serial_rx_dma))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_serial_rx_dma>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_serial_rx_dma))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).activated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_rx_dma),
            "::",
            stringify!(activated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_serial_tx_dma {
    pub activated: rt_bool_t,
    pub data_queue: rt_data_queue,
}
#[test]
fn bindgen_test_layout_rt_serial_tx_dma() {
    const UNINIT: ::core::mem::MaybeUninit<rt_serial_tx_dma> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_serial_tx_dma>(),
        40usize,
        concat!("Size of: ", stringify!(rt_serial_tx_dma))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_serial_tx_dma>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_serial_tx_dma))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).activated) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_tx_dma),
            "::",
            stringify!(activated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_queue) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_tx_dma),
            "::",
            stringify!(data_queue)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_serial_device {
    pub parent: rt_device,
    pub ops: *const rt_uart_ops,
    pub config: serial_configure,
    pub serial_rx: *mut core::ffi::c_void,
    pub serial_tx: *mut core::ffi::c_void,
    pub rx_notify: rt_device_notify,
}
#[test]
fn bindgen_test_layout_rt_serial_device() {
    const UNINIT: ::core::mem::MaybeUninit<rt_serial_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_serial_device>(),
        92usize,
        concat!("Size of: ", stringify!(rt_serial_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_serial_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_serial_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).config) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial_rx) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(serial_rx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serial_tx) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(serial_tx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_notify) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_serial_device),
            "::",
            stringify!(rx_notify)
        )
    );
}
pub type rt_serial_t = rt_serial_device;
#[doc = " uart operators"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_uart_ops {
    pub configure: ::core::option::Option<
        unsafe extern "C" fn(serial: *mut rt_serial_device, cfg: *mut serial_configure) -> rt_err_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            serial: *mut rt_serial_device,
            cmd: core::ffi::c_int,
            arg: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    pub putc: ::core::option::Option<
        unsafe extern "C" fn(
            serial: *mut rt_serial_device,
            c: core::ffi::c_char,
        ) -> core::ffi::c_int,
    >,
    pub getc: ::core::option::Option<
        unsafe extern "C" fn(serial: *mut rt_serial_device) -> core::ffi::c_int,
    >,
    pub dma_transmit: ::core::option::Option<
        unsafe extern "C" fn(
            serial: *mut rt_serial_device,
            buf: *mut rt_uint8_t,
            size: rt_size_t,
            direction: core::ffi::c_int,
        ) -> rt_ssize_t,
    >,
}
#[test]
fn bindgen_test_layout_rt_uart_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_uart_ops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_uart_ops>(),
        20usize,
        concat!("Size of: ", stringify!(rt_uart_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_uart_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_uart_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).configure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_uart_ops),
            "::",
            stringify!(configure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_uart_ops),
            "::",
            stringify!(control)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).putc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_uart_ops),
            "::",
            stringify!(putc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).getc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_uart_ops),
            "::",
            stringify!(getc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dma_transmit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_uart_ops),
            "::",
            stringify!(dma_transmit)
        )
    );
}
extern "C" {
    pub fn rt_hw_serial_isr(serial: *mut rt_serial_device, event: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_serial_register(
        serial: *mut rt_serial_device,
        name: *const core::ffi::c_char,
        flag: rt_uint32_t,
        data: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_pin {
    pub parent: rt_device,
    pub ops: *const rt_pin_ops,
}
#[test]
fn bindgen_test_layout_rt_device_pin() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_pin> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_pin>(),
        68usize,
        concat!("Size of: ", stringify!(rt_device_pin))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_pin>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_pin))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin),
            "::",
            stringify!(ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_pin_mode {
    pub pin: rt_base_t,
    pub mode: rt_uint8_t,
}
#[test]
fn bindgen_test_layout_rt_device_pin_mode() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_pin_mode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_pin_mode>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_pin_mode))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_pin_mode>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_pin_mode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin_mode),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin_mode),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_pin_value {
    pub pin: rt_base_t,
    pub value: rt_uint8_t,
}
#[test]
fn bindgen_test_layout_rt_device_pin_value() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_pin_value> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_pin_value>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_pin_value))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_pin_value>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_pin_value))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin_value),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_pin_value),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_pin_irq_hdr {
    pub pin: rt_base_t,
    pub mode: rt_uint8_t,
    pub hdr: ::core::option::Option<unsafe extern "C" fn(args: *mut core::ffi::c_void)>,
    pub args: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_pin_irq_hdr() {
    const UNINIT: ::core::mem::MaybeUninit<rt_pin_irq_hdr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_pin_irq_hdr>(),
        16usize,
        concat!("Size of: ", stringify!(rt_pin_irq_hdr))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_pin_irq_hdr>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_pin_irq_hdr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_irq_hdr),
            "::",
            stringify!(pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_irq_hdr),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_irq_hdr),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_irq_hdr),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_pin_ops {
    pub pin_mode: ::core::option::Option<
        unsafe extern "C" fn(device: *mut rt_device, pin: rt_base_t, mode: rt_uint8_t),
    >,
    pub pin_write: ::core::option::Option<
        unsafe extern "C" fn(device: *mut rt_device, pin: rt_base_t, value: rt_uint8_t),
    >,
    pub pin_read: ::core::option::Option<
        unsafe extern "C" fn(device: *mut rt_device, pin: rt_base_t) -> rt_int8_t,
    >,
    pub pin_attach_irq: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut rt_device,
            pin: rt_base_t,
            mode: rt_uint8_t,
            hdr: ::core::option::Option<unsafe extern "C" fn(args: *mut core::ffi::c_void)>,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
    pub pin_detach_irq: ::core::option::Option<
        unsafe extern "C" fn(device: *mut rt_device, pin: rt_base_t) -> rt_err_t,
    >,
    pub pin_irq_enable: ::core::option::Option<
        unsafe extern "C" fn(
            device: *mut rt_device,
            pin: rt_base_t,
            enabled: rt_uint8_t,
        ) -> rt_err_t,
    >,
    pub pin_get:
        ::core::option::Option<unsafe extern "C" fn(name: *const core::ffi::c_char) -> rt_base_t>,
}
#[test]
fn bindgen_test_layout_rt_pin_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_pin_ops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_pin_ops>(),
        28usize,
        concat!("Size of: ", stringify!(rt_pin_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_pin_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_pin_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_write) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_attach_irq) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_attach_irq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_detach_irq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_detach_irq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_irq_enable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_irq_enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pin_get) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_pin_ops),
            "::",
            stringify!(pin_get)
        )
    );
}
extern "C" {
    pub fn rt_device_pin_register(
        name: *const core::ffi::c_char,
        ops: *const rt_pin_ops,
        user_data: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_pin_mode(pin: rt_base_t, mode: rt_uint8_t);
}
extern "C" {
    pub fn rt_pin_write(pin: rt_base_t, value: rt_uint8_t);
}
extern "C" {
    pub fn rt_pin_read(pin: rt_base_t) -> rt_int8_t;
}
extern "C" {
    pub fn rt_pin_get(name: *const core::ffi::c_char) -> rt_base_t;
}
extern "C" {
    pub fn rt_pin_attach_irq(
        pin: rt_base_t,
        mode: rt_uint8_t,
        hdr: ::core::option::Option<unsafe extern "C" fn(args: *mut core::ffi::c_void)>,
        args: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_pin_detach_irq(pin: rt_base_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_pin_irq_enable(pin: rt_base_t, enabled: rt_uint8_t) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filesystem_ops {
    pub _address: u8,
}

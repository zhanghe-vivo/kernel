/* automatically generated by rust-bindgen 0.69.4 */

pub const RT_NAME_MAX: u32 = 8;
pub const RT_CPUS_NR: u32 = 2;
pub const RT_ALIGN_SIZE: u32 = 8;
pub const RT_THREAD_PRIORITY_MAX: u32 = 256;
pub const RT_TICK_PER_SECOND: u32 = 100;
pub const RT_IDLE_HOOK_LIST_SIZE: u32 = 4;
pub const IDLE_THREAD_STACK_SIZE: u32 = 4096;
pub const SYSTEM_THREAD_STACK_SIZE: u32 = 4096;
pub const RT_TIMER_THREAD_PRIO: u32 = 4;
pub const RT_TIMER_THREAD_STACK_SIZE: u32 = 4096;
pub const RT_PAGE_MAX_ORDER: u32 = 11;
pub const RT_CONSOLEBUF_SIZE: u32 = 256;
pub const RT_CONSOLE_DEVICE_NAME: &[u8; 6] = b"uart0\0";
pub const RT_VER_NUM: u32 = 327682;
pub const RT_MAIN_THREAD_STACK_SIZE: u32 = 4096;
pub const RT_MAIN_THREAD_PRIORITY: u32 = 10;
pub const FINSH_THREAD_NAME: &[u8; 7] = b"tshell\0";
pub const FINSH_THREAD_PRIORITY: u32 = 20;
pub const FINSH_THREAD_STACK_SIZE: u32 = 4096;
pub const FINSH_HISTORY_LINES: u32 = 10;
pub const FINSH_CMD_SIZE: u32 = 256;
pub const FINSH_ARG_MAX: u32 = 10;
pub const DFS_FD_MAX: u32 = 32;
pub const RT_DFS_ELM_CODE_PAGE: u32 = 437;
pub const RT_DFS_ELM_USE_LFN: u32 = 3;
pub const RT_DFS_ELM_LFN_UNICODE: u32 = 0;
pub const RT_DFS_ELM_MAX_LFN: u32 = 255;
pub const RT_DFS_ELM_DRIVES: u32 = 2;
pub const RT_DFS_ELM_MAX_SECTOR_SIZE: u32 = 4096;
pub const RT_DFS_ELM_MUTEX_TIMEOUT: u32 = 3000;
pub const RT_UNAMED_PIPE_NUMBER: u32 = 64;
pub const RT_SYSTEM_WORKQUEUE_STACKSIZE: u32 = 2048;
pub const RT_SYSTEM_WORKQUEUE_PRIORITY: u32 = 23;
pub const RT_SERIAL_RB_BUFSZ: u32 = 256;
pub const RT_SDIO_STACK_SIZE: u32 = 512;
pub const RT_SDIO_THREAD_PRIORITY: u32 = 15;
pub const RT_MMCSD_STACK_SIZE: u32 = 4096;
pub const RT_MMCSD_THREAD_PREORITY: u32 = 22;
pub const RT_MMCSD_MAX_PARTITION: u32 = 16;
pub const RT_SFUD_SPI_MAX_HZ: u32 = 50000000;
pub const RT_LIBC_TZ_DEFAULT_HOUR: u32 = 8;
pub const RT_LIBC_TZ_DEFAULT_MIN: u32 = 0;
pub const RT_LIBC_TZ_DEFAULT_SEC: u32 = 0;
pub const RT_USING_POSIX_PIPE_SIZE: u32 = 512;
pub const UTEST_THR_STACK_SIZE: u32 = 4096;
pub const UTEST_THR_PRIORITY: u32 = 20;
pub const RT_VERSION_MAJOR: u32 = 5;
pub const RT_VERSION_MINOR: u32 = 0;
pub const RT_VERSION_PATCH: u32 = 2;
pub const RT_TRUE: u32 = 1;
pub const RT_FALSE: u32 = 0;
pub const RT_NULL: u32 = 0;
pub const RT_UINT8_MAX: u32 = 255;
pub const RT_UINT16_MAX: u32 = 65535;
pub const RT_UINT32_MAX: u32 = 4294967295;
pub const RT_TICK_MAX: u32 = 4294967295;
pub const RT_SEM_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_VALUE_MAX: u32 = 65535;
pub const RT_MUTEX_HOLD_MAX: u32 = 255;
pub const RT_MB_ENTRY_MAX: u32 = 65535;
pub const RT_MQ_ENTRY_MAX: u32 = 65535;
pub const RT_EVENT_LENGTH: u32 = 32;
pub const RT_MM_PAGE_SIZE: u32 = 4096;
pub const RT_MM_PAGE_MASK: u32 = 4095;
pub const RT_MM_PAGE_BITS: u32 = 12;
pub const RT_EOK: u32 = 0;
pub const RT_ERROR: u32 = 1;
pub const RT_ETIMEOUT: u32 = 2;
pub const RT_EFULL: u32 = 3;
pub const RT_EEMPTY: u32 = 4;
pub const RT_ENOMEM: u32 = 5;
pub const RT_ENOSYS: u32 = 6;
pub const RT_EBUSY: u32 = 7;
pub const RT_EIO: u32 = 8;
pub const RT_EINTR: u32 = 9;
pub const RT_EINVAL: u32 = 10;
pub const RT_ENOENT: u32 = 11;
pub const RT_ENOSPC: u32 = 12;
pub const RT_EPERM: u32 = 13;
pub const RT_ETRAP: u32 = 14;
pub const RT_OBJECT_FLAG_MODULE: u32 = 128;
pub const USERMODE: u32 = 16;
pub const FIQMODE: u32 = 17;
pub const IRQMODE: u32 = 18;
pub const SVCMODE: u32 = 19;
pub const MONITORMODE: u32 = 22;
pub const ABORTMODE: u32 = 23;
pub const HYPMODE: u32 = 27;
pub const UNDEFMODE: u32 = 27;
pub const MODEMASK: u32 = 31;
pub const NOINT: u32 = 192;
pub const T_Bit: u32 = 32;
pub const F_Bit: u32 = 64;
pub const I_Bit: u32 = 128;
pub const A_Bit: u32 = 256;
pub const E_Bit: u32 = 512;
pub const J_Bit: u32 = 16777216;
pub const RT_TIMER_FLAG_DEACTIVATED: u32 = 0;
pub const RT_TIMER_FLAG_ACTIVATED: u32 = 1;
pub const RT_TIMER_FLAG_ONE_SHOT: u32 = 0;
pub const RT_TIMER_FLAG_PERIODIC: u32 = 2;
pub const RT_TIMER_FLAG_HARD_TIMER: u32 = 0;
pub const RT_TIMER_FLAG_SOFT_TIMER: u32 = 4;
pub const RT_TIMER_FLAG_THREAD_TIMER: u32 = 16;
pub const RT_TIMER_CTRL_SET_TIME: u32 = 0;
pub const RT_TIMER_CTRL_GET_TIME: u32 = 1;
pub const RT_TIMER_CTRL_SET_ONESHOT: u32 = 2;
pub const RT_TIMER_CTRL_SET_PERIODIC: u32 = 3;
pub const RT_TIMER_CTRL_GET_STATE: u32 = 4;
pub const RT_TIMER_CTRL_GET_REMAIN_TIME: u32 = 5;
pub const RT_TIMER_CTRL_GET_FUNC: u32 = 6;
pub const RT_TIMER_CTRL_SET_FUNC: u32 = 7;
pub const RT_TIMER_CTRL_GET_PARM: u32 = 8;
pub const RT_TIMER_CTRL_SET_PARM: u32 = 9;
pub const RT_TIMER_SKIP_LIST_LEVEL: u32 = 1;
pub const RT_TIMER_SKIP_LIST_MASK: u32 = 3;
pub const RT_THREAD_INIT: u32 = 0;
pub const RT_THREAD_CLOSE: u32 = 1;
pub const RT_THREAD_READY: u32 = 2;
pub const RT_THREAD_RUNNING: u32 = 3;
pub const RT_THREAD_SUSPEND_MASK: u32 = 4;
pub const RT_SIGNAL_COMMON_WAKEUP_MASK: u32 = 2;
pub const RT_SIGNAL_KILL_WAKEUP_MASK: u32 = 1;
pub const RT_THREAD_SUSPEND_INTERRUPTIBLE: u32 = 4;
pub const RT_THREAD_SUSPEND: u32 = 4;
pub const RT_THREAD_SUSPEND_KILLABLE: u32 = 6;
pub const RT_THREAD_SUSPEND_UNINTERRUPTIBLE: u32 = 7;
pub const RT_THREAD_STAT_MASK: u32 = 7;
pub const RT_THREAD_STAT_YIELD: u32 = 8;
pub const RT_THREAD_STAT_YIELD_MASK: u32 = 8;
pub const RT_THREAD_STAT_SIGNAL: u32 = 16;
pub const RT_THREAD_STAT_SIGNAL_READY: u32 = 18;
pub const RT_THREAD_STAT_SIGNAL_WAIT: u32 = 32;
pub const RT_THREAD_STAT_SIGNAL_PENDING: u32 = 64;
pub const RT_THREAD_STAT_SIGNAL_MASK: u32 = 240;
pub const RT_THREAD_CTRL_STARTUP: u32 = 0;
pub const RT_THREAD_CTRL_CLOSE: u32 = 1;
pub const RT_THREAD_CTRL_CHANGE_PRIORITY: u32 = 2;
pub const RT_THREAD_CTRL_INFO: u32 = 3;
pub const RT_THREAD_CTRL_BIND_CPU: u32 = 4;
pub const RT_CPU_DETACHED: u32 = 2;
pub const RT_CPU_MASK: u32 = 3;
pub const RT_SCHEDULE_IPI: u32 = 0;
pub const RT_STOP_IPI: u32 = 1;
pub const RT_IPC_FLAG_FIFO: u32 = 0;
pub const RT_IPC_FLAG_PRIO: u32 = 1;
pub const RT_IPC_CMD_UNKNOWN: u32 = 0;
pub const RT_IPC_CMD_RESET: u32 = 1;
pub const RT_IPC_CMD_GET_STATE: u32 = 2;
pub const RT_WAITING_FOREVER: i32 = -1;
pub const RT_WAITING_NO: u32 = 0;
pub const RT_EVENT_FLAG_AND: u32 = 1;
pub const RT_EVENT_FLAG_OR: u32 = 2;
pub const RT_EVENT_FLAG_CLEAR: u32 = 4;
pub const RT_DEVICE_FLAG_DEACTIVATE: u32 = 0;
pub const RT_DEVICE_FLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_FLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_FLAG_RDWR: u32 = 3;
pub const RT_DEVICE_FLAG_REMOVABLE: u32 = 4;
pub const RT_DEVICE_FLAG_STANDALONE: u32 = 8;
pub const RT_DEVICE_FLAG_ACTIVATED: u32 = 16;
pub const RT_DEVICE_FLAG_SUSPENDED: u32 = 32;
pub const RT_DEVICE_FLAG_STREAM: u32 = 64;
pub const RT_DEVICE_FLAG_INT_RX: u32 = 256;
pub const RT_DEVICE_FLAG_DMA_RX: u32 = 512;
pub const RT_DEVICE_FLAG_INT_TX: u32 = 1024;
pub const RT_DEVICE_FLAG_DMA_TX: u32 = 2048;
pub const RT_DEVICE_OFLAG_CLOSE: u32 = 0;
pub const RT_DEVICE_OFLAG_RDONLY: u32 = 1;
pub const RT_DEVICE_OFLAG_WRONLY: u32 = 2;
pub const RT_DEVICE_OFLAG_RDWR: u32 = 3;
pub const RT_DEVICE_OFLAG_OPEN: u32 = 8;
pub const RT_DEVICE_OFLAG_MASK: u32 = 3855;
pub const RT_DEVICE_CTRL_RESUME: u32 = 1;
pub const RT_DEVICE_CTRL_SUSPEND: u32 = 2;
pub const RT_DEVICE_CTRL_CONFIG: u32 = 3;
pub const RT_DEVICE_CTRL_CLOSE: u32 = 4;
pub const RT_DEVICE_CTRL_NOTIFY_SET: u32 = 5;
pub const RT_DEVICE_CTRL_SET_INT: u32 = 6;
pub const RT_DEVICE_CTRL_CLR_INT: u32 = 7;
pub const RT_DEVICE_CTRL_GET_INT: u32 = 8;
pub const RT_DEVICE_CTRL_CONSOLE_OFLAG: u32 = 9;
pub const RT_DEVICE_CTRL_MASK: u32 = 31;
pub const RT_DRIVER_MATCH_DTS: u32 = 1;
pub const RT_DEVICE_CTRL_CURSOR_SET_POSITION: u32 = 16;
pub const RT_DEVICE_CTRL_CURSOR_SET_TYPE: u32 = 17;
pub const RT_CPU_CACHE_LINE_SZ: u32 = 32;
pub const RT_VERSION: u32 = 5;
pub const RT_SUBVERSION: u32 = 0;
pub const RT_REVISION: u32 = 2;
pub type rt_bool_t = core::ffi::c_int;
pub type rt_base_t = core::ffi::c_long;
pub type rt_ubase_t = core::ffi::c_ulong;
pub type rt_int8_t = core::ffi::c_schar;
pub type rt_int16_t = core::ffi::c_short;
pub type rt_int32_t = core::ffi::c_int;
pub type rt_uint8_t = core::ffi::c_uchar;
pub type rt_uint16_t = core::ffi::c_ushort;
pub type rt_uint32_t = core::ffi::c_uint;
pub type rt_int64_t = core::ffi::c_longlong;
pub type rt_uint64_t = core::ffi::c_ulonglong;
pub type rt_size_t = rt_ubase_t;
pub type rt_ssize_t = rt_base_t;
pub type rt_err_t = rt_base_t;
pub type rt_time_t = rt_uint32_t;
pub type rt_tick_t = rt_uint32_t;
pub type rt_flag_t = rt_base_t;
pub type rt_dev_t = rt_ubase_t;
pub type rt_off_t = rt_base_t;
pub type rt_atomic_t = rt_base_t;
pub type __gnuc_va_list = u32;
pub type va_list = __gnuc_va_list;
pub type init_fn_t = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_init_desc {
    pub fn_name: *const core::ffi::c_char,
    pub fn_: init_fn_t,
}
#[test]
fn bindgen_test_layout_rt_init_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_init_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_init_desc>(),
        8usize,
        concat!("Size of: ", stringify!(rt_init_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_init_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_init_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fn_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_init_desc),
            "::",
            stringify!(fn_)
        )
    );
}
#[doc = " Double List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_list_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_list_node,
    #[doc = "< point to prev node."]
    pub prev: *mut rt_list_node,
}
#[test]
fn bindgen_test_layout_rt_list_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_list_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_list_node>(),
        8usize,
        concat!("Size of: ", stringify!(rt_list_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_list_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_list_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_list_node),
            "::",
            stringify!(prev)
        )
    );
}
#[doc = " Double List structure"]
pub type rt_list_t = rt_list_node;
#[doc = " Single List structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_slist_node {
    #[doc = "< point to next node."]
    pub next: *mut rt_slist_node,
}
#[test]
fn bindgen_test_layout_rt_slist_node() {
    const UNINIT: ::core::mem::MaybeUninit<rt_slist_node> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_slist_node>(),
        4usize,
        concat!("Size of: ", stringify!(rt_slist_node))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_slist_node>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_slist_node))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_slist_node),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Single List structure"]
pub type rt_slist_t = rt_slist_node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_hw_exp_stack {
    pub r0: core::ffi::c_ulong,
    pub r1: core::ffi::c_ulong,
    pub r2: core::ffi::c_ulong,
    pub r3: core::ffi::c_ulong,
    pub r4: core::ffi::c_ulong,
    pub r5: core::ffi::c_ulong,
    pub r6: core::ffi::c_ulong,
    pub r7: core::ffi::c_ulong,
    pub r8: core::ffi::c_ulong,
    pub r9: core::ffi::c_ulong,
    pub r10: core::ffi::c_ulong,
    pub fp: core::ffi::c_ulong,
    pub ip: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub lr: core::ffi::c_ulong,
    pub pc: core::ffi::c_ulong,
    pub cpsr: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_rt_hw_exp_stack() {
    const UNINIT: ::core::mem::MaybeUninit<rt_hw_exp_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_hw_exp_stack>(),
        68usize,
        concat!("Size of: ", stringify!(rt_hw_exp_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_hw_exp_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_hw_exp_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r3) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r4) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r5) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r7) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(pc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_exp_stack),
            "::",
            stringify!(cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_hw_stack {
    pub cpsr: core::ffi::c_ulong,
    pub r0: core::ffi::c_ulong,
    pub r1: core::ffi::c_ulong,
    pub r2: core::ffi::c_ulong,
    pub r3: core::ffi::c_ulong,
    pub r4: core::ffi::c_ulong,
    pub r5: core::ffi::c_ulong,
    pub r6: core::ffi::c_ulong,
    pub r7: core::ffi::c_ulong,
    pub r8: core::ffi::c_ulong,
    pub r9: core::ffi::c_ulong,
    pub r10: core::ffi::c_ulong,
    pub fp: core::ffi::c_ulong,
    pub ip: core::ffi::c_ulong,
    pub lr: core::ffi::c_ulong,
    pub pc: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_rt_hw_stack() {
    const UNINIT: ::core::mem::MaybeUninit<rt_hw_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_hw_stack>(),
        64usize,
        concat!("Size of: ", stringify!(rt_hw_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_hw_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_hw_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cpsr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(cpsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r5) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r6) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r7) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r8) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r9) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r10) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(r10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_stack),
            "::",
            stringify!(pc)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rt_hw_spinlock_t {
    pub slock: core::ffi::c_ulong,
    pub tickets: rt_hw_spinlock_t___arch_tickets,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_hw_spinlock_t___arch_tickets {
    pub owner: core::ffi::c_ushort,
    pub next: core::ffi::c_ushort,
}
#[test]
fn bindgen_test_layout_rt_hw_spinlock_t___arch_tickets() {
    const UNINIT: ::core::mem::MaybeUninit<rt_hw_spinlock_t___arch_tickets> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_hw_spinlock_t___arch_tickets>(),
        4usize,
        concat!("Size of: ", stringify!(rt_hw_spinlock_t___arch_tickets))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_hw_spinlock_t___arch_tickets>(),
        2usize,
        concat!("Alignment of ", stringify!(rt_hw_spinlock_t___arch_tickets))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_spinlock_t___arch_tickets),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_spinlock_t___arch_tickets),
            "::",
            stringify!(next)
        )
    );
}
#[test]
fn bindgen_test_layout_rt_hw_spinlock_t() {
    const UNINIT: ::core::mem::MaybeUninit<rt_hw_spinlock_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_hw_spinlock_t>(),
        4usize,
        concat!("Size of: ", stringify!(rt_hw_spinlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_hw_spinlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_hw_spinlock_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_spinlock_t),
            "::",
            stringify!(slock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tickets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_hw_spinlock_t),
            "::",
            stringify!(tickets)
        )
    );
}
extern "C" {
    pub fn _thread_start();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_spinlock {
    pub lock: rt_hw_spinlock_t,
}
#[test]
fn bindgen_test_layout_rt_spinlock() {
    const UNINIT: ::core::mem::MaybeUninit<rt_spinlock> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_spinlock>(),
        4usize,
        concat!("Size of: ", stringify!(rt_spinlock))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_spinlock>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_spinlock))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_spinlock),
            "::",
            stringify!(lock)
        )
    );
}
#[doc = "< The object is not used."]
pub const rt_object_class_type_RT_Object_Class_Null: rt_object_class_type = 0;
#[doc = "< The object is a thread."]
pub const rt_object_class_type_RT_Object_Class_Thread: rt_object_class_type = 1;
#[doc = "< The object is a semaphore."]
pub const rt_object_class_type_RT_Object_Class_Semaphore: rt_object_class_type = 2;
#[doc = "< The object is a mutex."]
pub const rt_object_class_type_RT_Object_Class_Mutex: rt_object_class_type = 3;
#[doc = "< The object is a event."]
pub const rt_object_class_type_RT_Object_Class_Event: rt_object_class_type = 4;
#[doc = "< The object is a mail box."]
pub const rt_object_class_type_RT_Object_Class_MailBox: rt_object_class_type = 5;
#[doc = "< The object is a message queue."]
pub const rt_object_class_type_RT_Object_Class_MessageQueue: rt_object_class_type = 6;
#[doc = "< The object is a memory heap."]
pub const rt_object_class_type_RT_Object_Class_MemHeap: rt_object_class_type = 7;
#[doc = "< The object is a memory pool."]
pub const rt_object_class_type_RT_Object_Class_MemPool: rt_object_class_type = 8;
#[doc = "< The object is a device."]
pub const rt_object_class_type_RT_Object_Class_Device: rt_object_class_type = 9;
#[doc = "< The object is a timer."]
pub const rt_object_class_type_RT_Object_Class_Timer: rt_object_class_type = 10;
#[doc = "< The object is a memory."]
pub const rt_object_class_type_RT_Object_Class_Memory: rt_object_class_type = 11;
#[doc = "< The object is a custom object"]
pub const rt_object_class_type_RT_Object_Class_Custom: rt_object_class_type = 12;
#[doc = "< The object is unknown."]
pub const rt_object_class_type_RT_Object_Class_Unknown: rt_object_class_type = 13;
#[doc = "< The object is a static object."]
pub const rt_object_class_type_RT_Object_Class_Static: rt_object_class_type = 128;
pub type rt_object_class_type = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_object {
    #[doc = "< dynamic name of kernel object"]
    pub name: [core::ffi::c_char; 8usize],
    #[doc = "< type of kernel object"]
    pub type_: rt_uint8_t,
    #[doc = "< flag of kernel object"]
    pub flag: rt_uint8_t,
    #[doc = "< list node of kernel object"]
    pub list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_object() {
    const UNINIT: ::core::mem::MaybeUninit<rt_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_object>(),
        20usize,
        concat!("Size of: ", stringify!(rt_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object),
            "::",
            stringify!(list)
        )
    );
}
pub type rt_object_t = *mut rt_object;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_object_information {
    pub spinlock: rt_spinlock,
    #[doc = "< object list"]
    pub object_list: rt_list_t,
    #[doc = "< object size"]
    pub object_size: rt_size_t,
    #[doc = "< object class type"]
    pub type_: rt_object_class_type,
}
#[test]
fn bindgen_test_layout_rt_object_information() {
    const UNINIT: ::core::mem::MaybeUninit<rt_object_information> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_object_information>(),
        20usize,
        concat!("Size of: ", stringify!(rt_object_information))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_object_information>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_object_information))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).object_list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(object_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).object_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(object_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_object_information),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " timer structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_timer {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    pub row: [rt_list_t; 1usize],
    #[doc = "< timeout function"]
    pub timeout_func:
        ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
    #[doc = "< timeout function's parameter"]
    pub parameter: *mut core::ffi::c_void,
    #[doc = "< timer timeout tick"]
    pub init_tick: rt_tick_t,
    #[doc = "< timeout tick"]
    pub timeout_tick: rt_tick_t,
}
#[test]
fn bindgen_test_layout_rt_timer() {
    const UNINIT: ::core::mem::MaybeUninit<rt_timer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_timer>(),
        44usize,
        concat!("Size of: ", stringify!(rt_timer))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_timer>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_timer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).row) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(row)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_func) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_tick) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_tick) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_timer),
            "::",
            stringify!(timeout_tick)
        )
    );
}
pub type rt_timer_t = *mut rt_timer;
pub const RT_INTERRUPTIBLE: _bindgen_ty_1 = 0;
pub const RT_KILLABLE: _bindgen_ty_1 = 1;
pub const RT_UNINTERRUPTIBLE: _bindgen_ty_1 = 2;
pub type _bindgen_ty_1 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_cpu {
    _unused: [u8; 0],
}
pub type rt_thread_cleanup_t = ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_stack {
    pub sp: rt_ubase_t,
    pub stack_addr: *mut rt_uint8_t,
    pub size: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_stack() {
    const UNINIT: ::core::mem::MaybeUninit<rt_stack> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_stack>(),
        12usize,
        concat!("Size of: ", stringify!(rt_stack))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_stack>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_stack))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_addr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(stack_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_stack),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rt_thread {
    pub parent: rt_object,
    pub tlist: rt_list_t,
    pub stat: rt_uint8_t,
    pub sched_flag_ttmr_set: rt_uint8_t,
    pub current_priority: rt_uint8_t,
    pub init_priority: rt_uint8_t,
    pub number: rt_uint8_t,
    pub high_mask: rt_uint8_t,
    pub number_mask: rt_uint32_t,
    pub init_tick: rt_tick_t,
    pub remaining_tick: rt_tick_t,
    pub thread_timer: rt_timer,
    pub sp: rt_ubase_t,
    pub stack_addr: *mut rt_uint8_t,
    pub stack_size: rt_size_t,
    pub entry: *mut core::ffi::c_void,
    pub parameter: *mut core::ffi::c_void,
    pub cleanup: *mut core::ffi::c_void,
    pub bind_cpu: rt_uint8_t,
    pub oncpu: rt_uint8_t,
    pub spinlock: rt_spinlock,
    pub error: rt_err_t,
    pub taken_object_list: rt_list_t,
    pub pending_object: rt_object_t,
    pub event_set: rt_uint32_t,
    pub event_info: rt_uint8_t,
}
#[test]
fn bindgen_test_layout_rt_thread() {
    const UNINIT: ::core::mem::MaybeUninit<rt_thread> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_thread>(),
        148usize,
        concat!("Size of: ", stringify!(rt_thread))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_thread))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tlist) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(tlist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stat) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_flag_ttmr_set) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(sched_flag_ttmr_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_priority) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(current_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_priority) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_mask) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(high_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).number_mask) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(number_mask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_tick) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(init_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remaining_tick) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(remaining_tick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thread_timer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(thread_timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_addr) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stack_size) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(parameter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cleanup) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bind_cpu) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(bind_cpu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).oncpu) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(oncpu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spinlock) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(spinlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_object_list) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(taken_object_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pending_object) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(pending_object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_set) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_info) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_thread),
            "::",
            stringify!(event_info)
        )
    );
}
pub type rt_thread_t = *mut rt_thread;
#[doc = " Base structure of IPC object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_ipc_object {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_ipc_object() {
    const UNINIT: ::core::mem::MaybeUninit<rt_ipc_object> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_ipc_object>(),
        28usize,
        concat!("Size of: ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_ipc_object>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_ipc_object))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_thread) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_ipc_object),
            "::",
            stringify!(suspend_thread)
        )
    );
}
#[doc = " Semaphore structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_semaphore {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< value of semaphore."]
    pub value: rt_uint16_t,
    #[doc = "< reserved field"]
    pub reserved: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_semaphore() {
    const UNINIT: ::core::mem::MaybeUninit<rt_semaphore> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_semaphore>(),
        32usize,
        concat!("Size of: ", stringify!(rt_semaphore))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_semaphore>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_semaphore))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_semaphore),
            "::",
            stringify!(reserved)
        )
    );
}
pub type rt_sem_t = *mut rt_semaphore;
#[doc = " Mutual exclusion (mutex) structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mutex {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< the priority ceiling of mutexe"]
    pub ceiling_priority: rt_uint8_t,
    #[doc = "< the maximal priority for pending thread"]
    pub priority: rt_uint8_t,
    #[doc = "< numbers of thread hold the mutex"]
    pub hold: rt_uint8_t,
    #[doc = "< reserved field"]
    pub reserved: rt_uint8_t,
    #[doc = "< current owner of mutex"]
    pub owner: *mut rt_thread,
    #[doc = "< the object list taken by thread"]
    pub taken_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mutex() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mutex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mutex>(),
        44usize,
        concat!("Size of: ", stringify!(rt_mutex))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mutex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ceiling_priority) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(ceiling_priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hold) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(hold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).taken_list) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mutex),
            "::",
            stringify!(taken_list)
        )
    );
}
pub type rt_mutex_t = *mut rt_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_event {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< event set"]
    pub set: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_event() {
    const UNINIT: ::core::mem::MaybeUninit<rt_event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_event>(),
        32usize,
        concat!("Size of: ", stringify!(rt_event))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_event>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_event),
            "::",
            stringify!(set)
        )
    );
}
pub type rt_event_t = *mut rt_event;
#[doc = " mailbox structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mailbox {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message buffer"]
    pub msg_pool: *mut rt_ubase_t,
    #[doc = "< size of message pool"]
    pub size: rt_uint16_t,
    #[doc = "< index of messages in msg_pool"]
    pub entry: rt_uint16_t,
    #[doc = "< input offset of the message buffer"]
    pub in_offset: rt_uint16_t,
    #[doc = "< output offset of the message buffer"]
    pub out_offset: rt_uint16_t,
    #[doc = "< sender thread suspended on this mailbox"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mailbox() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mailbox> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mailbox>(),
        48usize,
        concat!("Size of: ", stringify!(rt_mailbox))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mailbox>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mailbox))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_pool) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).in_offset) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(in_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).out_offset) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(out_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_sender_thread) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mailbox),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
pub type rt_mailbox_t = *mut rt_mailbox;
#[doc = " message queue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_messagequeue {
    #[doc = "< inherit from ipc_object"]
    pub parent: rt_ipc_object,
    #[doc = "< start address of message queue"]
    pub msg_pool: *mut core::ffi::c_void,
    #[doc = "< message size of each message"]
    pub msg_size: rt_uint16_t,
    #[doc = "< max number of messages"]
    pub max_msgs: rt_uint16_t,
    #[doc = "< index of messages in the queue"]
    pub entry: rt_uint16_t,
    #[doc = "< list head"]
    pub msg_queue_head: *mut core::ffi::c_void,
    #[doc = "< list tail"]
    pub msg_queue_tail: *mut core::ffi::c_void,
    #[doc = "< pointer indicated the free node of queue"]
    pub msg_queue_free: *mut core::ffi::c_void,
    #[doc = "< sender thread suspended on this message queue"]
    pub suspend_sender_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_messagequeue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_messagequeue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_messagequeue>(),
        60usize,
        concat!("Size of: ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_messagequeue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_messagequeue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_pool) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_pool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_msgs) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(max_msgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_head) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_tail) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_tail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg_queue_free) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(msg_queue_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_sender_thread) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_messagequeue),
            "::",
            stringify!(suspend_sender_thread)
        )
    );
}
pub type rt_mq_t = *mut rt_messagequeue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memory {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< Memory management algorithm name"]
    pub algorithm: *const core::ffi::c_char,
    #[doc = "< memory start address"]
    pub address: rt_ubase_t,
    #[doc = "< memory size"]
    pub total: rt_size_t,
    #[doc = "< size used"]
    pub used: rt_size_t,
    #[doc = "< maximum usage"]
    pub max: rt_size_t,
}
#[test]
fn bindgen_test_layout_rt_memory() {
    const UNINIT: ::core::mem::MaybeUninit<rt_memory> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_memory>(),
        40usize,
        concat!("Size of: ", stringify!(rt_memory))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_memory>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_memory))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algorithm) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(algorithm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memory),
            "::",
            stringify!(max)
        )
    );
}
pub type rt_mem_t = *mut rt_memory;
#[doc = " memory item on the heap"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memheap_item {
    #[doc = "< magic number for memheap"]
    pub magic: rt_uint32_t,
    #[doc = "< point of pool"]
    pub pool_ptr: *mut rt_memheap,
    #[doc = "< next memheap item"]
    pub next: *mut rt_memheap_item,
    #[doc = "< prev memheap item"]
    pub prev: *mut rt_memheap_item,
    #[doc = "< next free memheap item"]
    pub next_free: *mut rt_memheap_item,
    #[doc = "< prev free memheap item"]
    pub prev_free: *mut rt_memheap_item,
    #[doc = "< owner thread name"]
    pub owner_thread_name: [rt_uint8_t; 4usize],
}
#[test]
fn bindgen_test_layout_rt_memheap_item() {
    const UNINIT: ::core::mem::MaybeUninit<rt_memheap_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_memheap_item>(),
        28usize,
        concat!("Size of: ", stringify!(rt_memheap_item))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_memheap_item>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_memheap_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pool_ptr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(pool_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_free) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(next_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev_free) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(prev_free)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).owner_thread_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap_item),
            "::",
            stringify!(owner_thread_name)
        )
    );
}
#[doc = " Base structure of memory heap object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_memheap {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< pool start address and size"]
    pub start_addr: *mut core::ffi::c_void,
    #[doc = "< pool size"]
    pub pool_size: rt_size_t,
    #[doc = "< available size"]
    pub available_size: rt_size_t,
    #[doc = "< maximum allocated size"]
    pub max_used_size: rt_size_t,
    #[doc = "< used block list"]
    pub block_list: *mut rt_memheap_item,
    #[doc = "< free block list"]
    pub free_list: *mut rt_memheap_item,
    #[doc = "< free block list header"]
    pub free_header: rt_memheap_item,
    #[doc = "< semaphore lock"]
    pub lock: rt_semaphore,
    #[doc = "< External lock mark"]
    pub locked: rt_bool_t,
}
#[test]
fn bindgen_test_layout_rt_memheap() {
    const UNINIT: ::core::mem::MaybeUninit<rt_memheap> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_memheap>(),
        108usize,
        concat!("Size of: ", stringify!(rt_memheap))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_memheap>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_memheap))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_addr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(start_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pool_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(pool_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).available_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(available_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_used_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(max_used_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_list) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(block_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_list) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_header) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(free_header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locked) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_memheap),
            "::",
            stringify!(locked)
        )
    );
}
#[doc = " Base structure of Memory pool object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mempool {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< memory pool start"]
    pub start_address: *mut core::ffi::c_void,
    #[doc = "< size of memory pool"]
    pub size: rt_size_t,
    #[doc = "< size of memory blocks"]
    pub block_size: rt_size_t,
    #[doc = "< memory blocks list"]
    pub block_list: *mut rt_uint8_t,
    #[doc = "< numbers of memory block"]
    pub block_total_count: rt_size_t,
    #[doc = "< numbers of free memory block"]
    pub block_free_count: rt_size_t,
    #[doc = "< threads pended on this resource"]
    pub suspend_thread: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_mempool() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mempool> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mempool>(),
        52usize,
        concat!("Size of: ", stringify!(rt_mempool))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mempool>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mempool))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_address) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(start_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_list) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_total_count) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_total_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_free_count) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(block_free_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suspend_thread) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mempool),
            "::",
            stringify!(suspend_thread)
        )
    );
}
pub type rt_mp_t = *mut rt_mempool;
#[doc = "< character device"]
pub const rt_device_class_type_RT_Device_Class_Char: rt_device_class_type = 0;
#[doc = "< block device"]
pub const rt_device_class_type_RT_Device_Class_Block: rt_device_class_type = 1;
#[doc = "< net interface"]
pub const rt_device_class_type_RT_Device_Class_NetIf: rt_device_class_type = 2;
#[doc = "< memory device"]
pub const rt_device_class_type_RT_Device_Class_MTD: rt_device_class_type = 3;
#[doc = "< CAN device"]
pub const rt_device_class_type_RT_Device_Class_CAN: rt_device_class_type = 4;
#[doc = "< RTC device"]
pub const rt_device_class_type_RT_Device_Class_RTC: rt_device_class_type = 5;
#[doc = "< Sound device"]
pub const rt_device_class_type_RT_Device_Class_Sound: rt_device_class_type = 6;
#[doc = "< Graphic device"]
pub const rt_device_class_type_RT_Device_Class_Graphic: rt_device_class_type = 7;
#[doc = "< I2C bus device"]
pub const rt_device_class_type_RT_Device_Class_I2CBUS: rt_device_class_type = 8;
#[doc = "< USB slave device"]
pub const rt_device_class_type_RT_Device_Class_USBDevice: rt_device_class_type = 9;
#[doc = "< USB host bus"]
pub const rt_device_class_type_RT_Device_Class_USBHost: rt_device_class_type = 10;
#[doc = "< USB OTG bus"]
pub const rt_device_class_type_RT_Device_Class_USBOTG: rt_device_class_type = 11;
#[doc = "< SPI bus device"]
pub const rt_device_class_type_RT_Device_Class_SPIBUS: rt_device_class_type = 12;
#[doc = "< SPI device"]
pub const rt_device_class_type_RT_Device_Class_SPIDevice: rt_device_class_type = 13;
#[doc = "< SDIO bus device"]
pub const rt_device_class_type_RT_Device_Class_SDIO: rt_device_class_type = 14;
#[doc = "< PM pseudo device"]
pub const rt_device_class_type_RT_Device_Class_PM: rt_device_class_type = 15;
#[doc = "< Pipe device"]
pub const rt_device_class_type_RT_Device_Class_Pipe: rt_device_class_type = 16;
#[doc = "< Portal device"]
pub const rt_device_class_type_RT_Device_Class_Portal: rt_device_class_type = 17;
#[doc = "< Timer device"]
pub const rt_device_class_type_RT_Device_Class_Timer: rt_device_class_type = 18;
#[doc = "< Miscellaneous device"]
pub const rt_device_class_type_RT_Device_Class_Miscellaneous: rt_device_class_type = 19;
#[doc = "< Sensor device"]
pub const rt_device_class_type_RT_Device_Class_Sensor: rt_device_class_type = 20;
#[doc = "< Touch device"]
pub const rt_device_class_type_RT_Device_Class_Touch: rt_device_class_type = 21;
#[doc = "< PHY device"]
pub const rt_device_class_type_RT_Device_Class_PHY: rt_device_class_type = 22;
#[doc = "< Security device"]
pub const rt_device_class_type_RT_Device_Class_Security: rt_device_class_type = 23;
#[doc = "< WLAN device"]
pub const rt_device_class_type_RT_Device_Class_WLAN: rt_device_class_type = 24;
#[doc = "< Pin device"]
pub const rt_device_class_type_RT_Device_Class_Pin: rt_device_class_type = 25;
#[doc = "< ADC device"]
pub const rt_device_class_type_RT_Device_Class_ADC: rt_device_class_type = 26;
#[doc = "< DAC device"]
pub const rt_device_class_type_RT_Device_Class_DAC: rt_device_class_type = 27;
#[doc = "< WDT device"]
pub const rt_device_class_type_RT_Device_Class_WDT: rt_device_class_type = 28;
#[doc = "< PWM device"]
pub const rt_device_class_type_RT_Device_Class_PWM: rt_device_class_type = 29;
#[doc = "< Bus device"]
pub const rt_device_class_type_RT_Device_Class_Bus: rt_device_class_type = 30;
#[doc = "< unknown device"]
pub const rt_device_class_type_RT_Device_Class_Unknown: rt_device_class_type = 31;
#[doc = " device (I/O) class type"]
pub type rt_device_class_type = core::ffi::c_uint;
pub type rt_device_t = *mut rt_device;
#[doc = " operations set for device object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_ops {
    pub init: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub open: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t,
    >,
    pub close: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t) -> rt_err_t>,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *mut core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            pos: rt_off_t,
            buffer: *const core::ffi::c_void,
            size: rt_size_t,
        ) -> rt_ssize_t,
    >,
    pub control: ::core::option::Option<
        unsafe extern "C" fn(
            dev: rt_device_t,
            cmd: core::ffi::c_int,
            args: *mut core::ffi::c_void,
        ) -> rt_err_t,
    >,
}
#[test]
fn bindgen_test_layout_rt_device_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_ops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_ops>(),
        24usize,
        concat!("Size of: ", stringify!(rt_device_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).control) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_ops),
            "::",
            stringify!(control)
        )
    );
}
#[doc = " WaitQueue structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_wqueue {
    pub flag: rt_uint32_t,
    pub waiting_list: rt_list_t,
}
#[test]
fn bindgen_test_layout_rt_wqueue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_wqueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_wqueue>(),
        12usize,
        concat!("Size of: ", stringify!(rt_wqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_wqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_wqueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waiting_list) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_wqueue),
            "::",
            stringify!(waiting_list)
        )
    );
}
#[doc = " WaitQueue structure"]
pub type rt_wqueue_t = rt_wqueue;
#[doc = " Device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device {
    #[doc = "< inherit from rt_object"]
    pub parent: rt_object,
    #[doc = "< device type"]
    pub type_: rt_device_class_type,
    #[doc = "< device flag"]
    pub flag: rt_uint16_t,
    #[doc = "< device open flag"]
    pub open_flag: rt_uint16_t,
    #[doc = "< reference count"]
    pub ref_count: rt_uint8_t,
    #[doc = "< 0 - 255"]
    pub device_id: rt_uint8_t,
    pub rx_indicate:
        ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t>,
    pub tx_complete: ::core::option::Option<
        unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
    >,
    pub ops: *const rt_device_ops,
    pub fops: *mut dfs_file_ops,
    pub wait_queue: rt_wqueue,
    #[doc = "< device private data"]
    pub user_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device>(),
        64usize,
        concat!("Size of: ", stringify!(rt_device))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_flag) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(open_flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_count) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_id) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_indicate) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(rx_indicate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_complete) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(tx_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fops) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait_queue) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(wait_queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_id {
    pub compatible: *const core::ffi::c_char,
    pub data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_device_id() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_id> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_id>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_id))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_id>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_id))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).compatible) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(compatible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_id),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_driver {
    pub dev_ops: *const rt_device_ops,
    pub fops: *mut filesystem_ops,
    pub name: *const core::ffi::c_char,
    pub dev_type: rt_device_class_type,
    pub device_size: core::ffi::c_int,
    pub flag: core::ffi::c_int,
    pub dev_match: *const rt_device_id,
    pub probe:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub probe_init:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub remove:
        ::core::option::Option<unsafe extern "C" fn(dev: *mut rt_device) -> core::ffi::c_int>,
    pub ops: *const core::ffi::c_void,
    pub drv_priv_data: *mut core::ffi::c_void,
}
#[test]
fn bindgen_test_layout_rt_driver() {
    const UNINIT: ::core::mem::MaybeUninit<rt_driver> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_driver>(),
        48usize,
        concat!("Size of: ", stringify!(rt_driver))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_driver>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_driver))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_ops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fops) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(fops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(device_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flag) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev_match) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(dev_match)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).probe_init) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(probe_init)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drv_priv_data) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_driver),
            "::",
            stringify!(drv_priv_data)
        )
    );
}
pub type rt_driver_t = *mut rt_driver;
#[doc = " Notify structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_notify {
    pub notify: ::core::option::Option<unsafe extern "C" fn(dev: rt_device_t)>,
    pub dev: *mut rt_device,
}
#[test]
fn bindgen_test_layout_rt_device_notify() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_notify> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_notify>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_notify))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_notify>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_notify))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_notify),
            "::",
            stringify!(dev)
        )
    );
}
#[doc = " block device geometry structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_geometry {
    #[doc = "< count of sectors"]
    pub sector_count: rt_uint64_t,
    #[doc = "< number of bytes per sector"]
    pub bytes_per_sector: rt_uint32_t,
    #[doc = "< number of bytes to erase one block"]
    pub block_size: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_geometry() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_geometry> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_geometry>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_geometry>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_geometry))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(sector_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bytes_per_sector) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(bytes_per_sector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_geometry),
            "::",
            stringify!(block_size)
        )
    );
}
#[doc = " sector arrange struct on block device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_blk_sectors {
    #[doc = "< begin sector"]
    pub sector_begin: rt_uint64_t,
    #[doc = "< end sector"]
    pub sector_end: rt_uint64_t,
}
#[test]
fn bindgen_test_layout_rt_device_blk_sectors() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_blk_sectors> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_blk_sectors>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_blk_sectors>(),
        8usize,
        concat!("Alignment of ", stringify!(rt_device_blk_sectors))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sector_end) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_blk_sectors),
            "::",
            stringify!(sector_end)
        )
    );
}
pub const RTGRAPHIC_PIXEL_FORMAT_MONO: _bindgen_ty_2 = 0;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY4: _bindgen_ty_2 = 1;
pub const RTGRAPHIC_PIXEL_FORMAT_GRAY16: _bindgen_ty_2 = 2;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB332: _bindgen_ty_2 = 3;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB444: _bindgen_ty_2 = 4;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565: _bindgen_ty_2 = 5;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB565P: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR565: _bindgen_ty_2 = 6;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB666: _bindgen_ty_2 = 7;
pub const RTGRAPHIC_PIXEL_FORMAT_RGB888: _bindgen_ty_2 = 8;
pub const RTGRAPHIC_PIXEL_FORMAT_BGR888: _bindgen_ty_2 = 9;
pub const RTGRAPHIC_PIXEL_FORMAT_ARGB888: _bindgen_ty_2 = 10;
pub const RTGRAPHIC_PIXEL_FORMAT_ABGR888: _bindgen_ty_2 = 11;
pub const RTGRAPHIC_PIXEL_FORMAT_RESERVED: _bindgen_ty_2 = 12;
pub type _bindgen_ty_2 = core::ffi::c_uint;
#[doc = " graphic device information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_info {
    #[doc = "< graphic format"]
    pub pixel_format: rt_uint8_t,
    #[doc = "< bits per pixel"]
    pub bits_per_pixel: rt_uint8_t,
    #[doc = "< bytes per line"]
    pub pitch: rt_uint16_t,
    #[doc = "< width of graphic device"]
    pub width: rt_uint16_t,
    #[doc = "< height of graphic device"]
    pub height: rt_uint16_t,
    #[doc = "< frame buffer"]
    pub framebuffer: *mut rt_uint8_t,
    #[doc = "< allocated frame buffer size"]
    pub smem_len: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_info>(),
        16usize,
        concat!("Size of: ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixel_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bits_per_pixel) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(bits_per_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).framebuffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(framebuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).smem_len) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_info),
            "::",
            stringify!(smem_len)
        )
    );
}
#[doc = " rectangle information structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_rect_info {
    #[doc = "< x coordinate"]
    pub x: rt_uint16_t,
    #[doc = "< y coordinate"]
    pub y: rt_uint16_t,
    #[doc = "< width"]
    pub width: rt_uint16_t,
    #[doc = "< height"]
    pub height: rt_uint16_t,
}
#[test]
fn bindgen_test_layout_rt_device_rect_info() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_rect_info> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_rect_info>(),
        8usize,
        concat!("Size of: ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_rect_info>(),
        2usize,
        concat!("Alignment of ", stringify!(rt_device_rect_info))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_rect_info),
            "::",
            stringify!(height)
        )
    );
}
#[doc = " graphic operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_device_graphic_ops {
    pub set_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub get_pixel: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *mut core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_hline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x1: core::ffi::c_int,
            x2: core::ffi::c_int,
            y: core::ffi::c_int,
        ),
    >,
    pub draw_vline: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y1: core::ffi::c_int,
            y2: core::ffi::c_int,
        ),
    >,
    pub blit_line: ::core::option::Option<
        unsafe extern "C" fn(
            pixel: *const core::ffi::c_char,
            x: core::ffi::c_int,
            y: core::ffi::c_int,
            size: rt_size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout_rt_device_graphic_ops() {
    const UNINIT: ::core::mem::MaybeUninit<rt_device_graphic_ops> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_device_graphic_ops>(),
        20usize,
        concat!("Size of: ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_device_graphic_ops>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_device_graphic_ops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_pixel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(set_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pixel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(get_pixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_hline) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_hline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draw_vline) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(draw_vline)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blit_line) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_device_graphic_ops),
            "::",
            stringify!(blit_line)
        )
    );
}
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_FLUSH: RT_HW_CACHE_OPS = 1;
pub const RT_HW_CACHE_OPS_RT_HW_CACHE_INVALIDATE: RT_HW_CACHE_OPS = 2;
pub type RT_HW_CACHE_OPS = core::ffi::c_uint;
extern "C" {
    pub fn rt_hw_cpu_icache_enable();
}
extern "C" {
    pub fn rt_hw_cpu_icache_disable();
}
extern "C" {
    pub fn rt_hw_cpu_icache_status() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_cpu_icache_ops(
        ops: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        size: core::ffi::c_int,
    );
}
extern "C" {
    pub fn rt_hw_cpu_dcache_enable();
}
extern "C" {
    pub fn rt_hw_cpu_dcache_disable();
}
extern "C" {
    pub fn rt_hw_cpu_dcache_status() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_cpu_dcache_ops(
        ops: core::ffi::c_int,
        addr: *mut core::ffi::c_void,
        size: core::ffi::c_int,
    );
}
extern "C" {
    pub fn rt_hw_cpu_reset();
}
extern "C" {
    pub fn rt_hw_cpu_shutdown();
}
extern "C" {
    pub fn rt_hw_cpu_arch() -> *const core::ffi::c_char;
}
extern "C" {
    pub fn rt_hw_stack_init(
        entry: *mut core::ffi::c_void,
        parameter: *mut core::ffi::c_void,
        stack_addr: *mut rt_uint8_t,
        exit: *mut core::ffi::c_void,
    ) -> *mut rt_uint8_t;
}
pub type rt_isr_handler_t = ::core::option::Option<
    unsafe extern "C" fn(vector: core::ffi::c_int, param: *mut core::ffi::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_irq_desc {
    pub handler: rt_isr_handler_t,
    pub param: *mut core::ffi::c_void,
    pub name: [core::ffi::c_char; 8usize],
    pub counter: rt_uint32_t,
}
#[test]
fn bindgen_test_layout_rt_irq_desc() {
    const UNINIT: ::core::mem::MaybeUninit<rt_irq_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_irq_desc>(),
        20usize,
        concat!("Size of: ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_irq_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_irq_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).param) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(param)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_irq_desc),
            "::",
            stringify!(counter)
        )
    );
}
extern "C" {
    pub fn rt_hw_interrupt_init();
}
extern "C" {
    pub fn rt_hw_interrupt_mask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_umask(vector: core::ffi::c_int);
}
extern "C" {
    pub fn rt_hw_interrupt_install(
        vector: core::ffi::c_int,
        handler: rt_isr_handler_t,
        param: *mut core::ffi::c_void,
        name: *const core::ffi::c_char,
    ) -> rt_isr_handler_t;
}
extern "C" {
    pub fn rt_hw_local_irq_disable() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_local_irq_enable(level: rt_base_t);
}
extern "C" {
    pub fn rt_sched_unlock(level: rt_base_t);
}
extern "C" {
    pub fn rt_sched_lock() -> rt_base_t;
}
extern "C" {
    pub fn rt_hw_interrupt_is_disabled() -> rt_bool_t;
}
extern "C" {
    pub fn rt_hw_context_switch(from: rt_ubase_t, to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_to(to: rt_ubase_t, to_thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_hw_context_switch_interrupt(
        context: *mut core::ffi::c_void,
        from: rt_ubase_t,
        to: rt_ubase_t,
        to_thread: *mut rt_thread,
    );
}
extern "C" {
    pub fn rt_hw_console_output(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_hw_backtrace(fp: *mut rt_uint32_t, thread_entry: rt_ubase_t);
}
extern "C" {
    pub fn rt_hw_show_memory(addr: rt_uint32_t, size: rt_size_t);
}
extern "C" {
    pub fn rt_hw_exception_install(
        exception_handle: ::core::option::Option<
            unsafe extern "C" fn(context: *mut core::ffi::c_void) -> rt_err_t,
        >,
    );
}
extern "C" {
    pub fn rt_hw_us_delay(us: rt_uint32_t);
}
extern "C" {
    pub fn rt_hw_cpu_id() -> core::ffi::c_int;
}
extern "C" {
    #[doc = "  ipi function"]
    pub fn rt_hw_ipi_send(ipi_vector: core::ffi::c_int, cpu_mask: core::ffi::c_uint);
}
extern "C" {
    pub fn rt_hw_spin_lock_init(lock: *mut rt_hw_spinlock_t);
}
extern "C" {
    pub fn rt_hw_spin_lock(lock: *mut rt_hw_spinlock_t);
}
extern "C" {
    pub fn rt_hw_spin_unlock(lock: *mut rt_hw_spinlock_t);
}
extern "C" {
    #[doc = " boot secondary cpu"]
    pub fn rt_hw_secondary_cpu_up();
}
extern "C" {
    #[doc = " secondary cpu idle function"]
    pub fn rt_hw_secondary_cpu_idle_exec();
}
extern "C" {
    pub fn rt_hw_atomic_load(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_store(ptr: *mut rt_atomic_t, val: rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_add(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_sub(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_and(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_or(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_xor(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_exchange(ptr: *mut rt_atomic_t, val: rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_flag_clear(ptr: *mut rt_atomic_t);
}
extern "C" {
    pub fn rt_hw_atomic_flag_test_and_set(ptr: *mut rt_atomic_t) -> rt_atomic_t;
}
extern "C" {
    pub fn rt_hw_atomic_compare_exchange_strong(
        ptr: *mut rt_atomic_t,
        expected: *mut rt_atomic_t,
        desired: rt_atomic_t,
    ) -> rt_atomic_t;
}
pub const RT_WORK_STATE_PENDING: _bindgen_ty_3 = 1;
pub const RT_WORK_STATE_SUBMITTING: _bindgen_ty_3 = 2;
pub type _bindgen_ty_3 = core::ffi::c_uint;
pub const RT_WORK_TYPE_DELAYED: _bindgen_ty_4 = 1;
#[doc = " work type definitions"]
pub type _bindgen_ty_4 = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_workqueue {
    pub work_list: rt_list_t,
    pub delayed_list: rt_list_t,
    pub work_current: *mut rt_work,
    pub sem: rt_semaphore,
    pub work_thread: rt_thread_t,
}
#[test]
fn bindgen_test_layout_rt_workqueue() {
    const UNINIT: ::core::mem::MaybeUninit<rt_workqueue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_workqueue>(),
        56usize,
        concat!("Size of: ", stringify!(rt_workqueue))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_workqueue>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_workqueue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delayed_list) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(delayed_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_thread) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_workqueue),
            "::",
            stringify!(work_thread)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_work {
    pub list: rt_list_t,
    pub work_func: ::core::option::Option<
        unsafe extern "C" fn(work: *mut rt_work, work_data: *mut core::ffi::c_void),
    >,
    pub work_data: *mut core::ffi::c_void,
    pub flags: rt_uint16_t,
    pub type_: rt_uint16_t,
    pub timer: rt_timer,
    pub workqueue: *mut rt_workqueue,
}
#[test]
fn bindgen_test_layout_rt_work() {
    const UNINIT: ::core::mem::MaybeUninit<rt_work> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_work>(),
        68usize,
        concat!("Size of: ", stringify!(rt_work))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_work>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_work))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).list) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(work_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(work_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).workqueue) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_work),
            "::",
            stringify!(workqueue)
        )
    );
}
extern "C" {
    #[doc = " WorkQueue for DeviceDriver"]
    pub fn rt_work_init(
        work: *mut rt_work,
        work_func: ::core::option::Option<
            unsafe extern "C" fn(work: *mut rt_work, work_data: *mut core::ffi::c_void),
        >,
        work_data: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rt_workqueue_create(
        name: *const core::ffi::c_char,
        stack_size: rt_uint16_t,
        priority: rt_uint8_t,
    ) -> *mut rt_workqueue;
}
extern "C" {
    pub fn rt_workqueue_destroy(queue: *mut rt_workqueue) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_dowork(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_submit_work(
        queue: *mut rt_workqueue,
        work: *mut rt_work,
        ticks: rt_tick_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_work(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_work_sync(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_cancel_all_work(queue: *mut rt_workqueue) -> rt_err_t;
}
extern "C" {
    pub fn rt_workqueue_urgent_work(queue: *mut rt_workqueue, work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_work_submit(work: *mut rt_work, ticks: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_work_urgent(work: *mut rt_work) -> rt_err_t;
}
extern "C" {
    pub fn rt_work_cancel(work: *mut rt_work) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_delayed_work {
    pub work: rt_work,
}
#[test]
fn bindgen_test_layout_rt_delayed_work() {
    const UNINIT: ::core::mem::MaybeUninit<rt_delayed_work> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_delayed_work>(),
        68usize,
        concat!("Size of: ", stringify!(rt_delayed_work))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_delayed_work>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_delayed_work))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).work) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_delayed_work),
            "::",
            stringify!(work)
        )
    );
}
extern "C" {
    pub fn rt_delayed_work_init(
        work: *mut rt_delayed_work,
        work_func: ::core::option::Option<
            unsafe extern "C" fn(work: *mut rt_work, work_data: *mut core::ffi::c_void),
        >,
        work_data: *mut core::ffi::c_void,
    );
}
pub type syscall_func = ::core::option::Option<unsafe extern "C" fn() -> core::ffi::c_long>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall {
    pub name: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub opt: *mut msh_cmd_opt,
    pub func: syscall_func,
}
#[test]
fn bindgen_test_layout_finsh_syscall() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall>(),
        16usize,
        concat!("Size of: ", stringify!(finsh_syscall))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(opt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct finsh_syscall_item {
    pub next: *mut finsh_syscall_item,
    pub syscall: finsh_syscall,
}
#[test]
fn bindgen_test_layout_finsh_syscall_item() {
    const UNINIT: ::core::mem::MaybeUninit<finsh_syscall_item> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<finsh_syscall_item>(),
        20usize,
        concat!("Size of: ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        ::core::mem::align_of::<finsh_syscall_item>(),
        4usize,
        concat!("Alignment of ", stringify!(finsh_syscall_item))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syscall) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(finsh_syscall_item),
            "::",
            stringify!(syscall)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msh_cmd_opt {
    pub id: rt_uint32_t,
    pub name: *const core::ffi::c_char,
    pub des: *const core::ffi::c_char,
}
#[test]
fn bindgen_test_layout_msh_cmd_opt() {
    const UNINIT: ::core::mem::MaybeUninit<msh_cmd_opt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<msh_cmd_opt>(),
        12usize,
        concat!("Size of: ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        ::core::mem::align_of::<msh_cmd_opt>(),
        4usize,
        concat!("Alignment of ", stringify!(msh_cmd_opt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).des) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msh_cmd_opt),
            "::",
            stringify!(des)
        )
    );
}
pub type msh_cmd_opt_t = msh_cmd_opt;
extern "C" {
    pub fn msh_opt_list_dump(options: *mut core::ffi::c_void);
}
extern "C" {
    pub fn msh_cmd_opt_id_get(
        argc: core::ffi::c_int,
        argv: *mut *mut core::ffi::c_char,
        options: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub static mut global_syscall_list: *mut finsh_syscall_item;
}
extern "C" {
    pub static mut _syscall_table_begin: *mut finsh_syscall;
}
extern "C" {
    pub static mut _syscall_table_end: *mut finsh_syscall;
}
extern "C" {
    pub fn finsh_syscall_lookup(name: *const core::ffi::c_char) -> *mut finsh_syscall;
}
extern "C" {
    #[doc = " @addtogroup KernelObject\n @{"]
    pub fn rt_object_get_information(type_: rt_object_class_type) -> *mut rt_object_information;
}
extern "C" {
    pub fn rt_object_get_length(type_: rt_object_class_type) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_get_pointers(
        type_: rt_object_class_type,
        pointers: *mut rt_object_t,
        maxlen: rt_size_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_object_init(
        object: *mut rt_object,
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    );
}
extern "C" {
    pub fn rt_object_detach(object: rt_object_t);
}
extern "C" {
    pub fn rt_object_allocate(
        type_: rt_object_class_type,
        name: *const core::ffi::c_char,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_delete(object: rt_object_t);
}
extern "C" {
    pub fn rt_custom_object_create(
        name: *const core::ffi::c_char,
        data: *mut core::ffi::c_void,
        data_destroy: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_object_t;
}
extern "C" {
    pub fn rt_custom_object_destroy(obj: rt_object_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_object_is_systemobject(object: rt_object_t) -> rt_bool_t;
}
extern "C" {
    pub fn rt_object_get_type(object: rt_object_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_object_find(name: *const core::ffi::c_char, type_: rt_uint8_t) -> rt_object_t;
}
extern "C" {
    pub fn rt_object_get_name(
        object: rt_object_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_object_attach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_detach_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_trytake_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_take_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    pub fn rt_object_put_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(object: *mut rt_object)>,
    );
}
extern "C" {
    #[doc = " @addtogroup Clock\n @{"]
    pub fn rt_tick_get() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_set(tick: rt_tick_t);
}
extern "C" {
    pub fn rt_tick_increase();
}
extern "C" {
    pub fn rt_tick_from_millisecond(ms: rt_int32_t) -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_get_millisecond() -> rt_tick_t;
}
extern "C" {
    pub fn rt_tick_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_system_timer_init();
}
extern "C" {
    pub fn rt_system_timer_thread_init();
}
extern "C" {
    pub fn rt_timer_init(
        timer: rt_timer_t,
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    );
}
extern "C" {
    pub fn rt_timer_detach(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_create(
        name: *const core::ffi::c_char,
        timeout: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        time: rt_tick_t,
        flag: rt_uint8_t,
    ) -> rt_timer_t;
}
extern "C" {
    pub fn rt_timer_delete(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_start(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_stop(timer: rt_timer_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_control(
        timer: rt_timer_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_timer_next_timeout_tick() -> rt_tick_t;
}
extern "C" {
    pub fn rt_timer_check();
}
extern "C" {
    pub fn rt_timer_enter_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    pub fn rt_timer_exit_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(timer: *mut rt_timer)>,
    );
}
extern "C" {
    #[doc = " @addtogroup Thread\n @{"]
    pub fn rt_thread_init(
        thread: *mut rt_thread,
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_start: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_detach(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_create(
        name: *const core::ffi::c_char,
        entry: ::core::option::Option<unsafe extern "C" fn(parameter: *mut core::ffi::c_void)>,
        parameter: *mut core::ffi::c_void,
        stack_size: rt_uint32_t,
        priority: rt_uint8_t,
        tick: rt_uint32_t,
    ) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_delete(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_self() -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_find(name: *mut core::ffi::c_char) -> rt_thread_t;
}
extern "C" {
    pub fn rt_thread_startup(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_yield() -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_delay(tick: rt_tick_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_mdelay(ms: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_control(
        thread: rt_thread_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend_with_flag(thread: rt_thread_t, suspend_flag: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_resume(thread: rt_thread_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_timeout(parameter: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_thread_get_name(
        thread: rt_thread_t,
        name: *mut core::ffi::c_char,
        name_size: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_suspend_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_resume_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_inited_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(thread: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_thread_idle_init();
}
extern "C" {
    pub fn rt_thread_idle_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_delhook(hook: ::core::option::Option<unsafe extern "C" fn()>)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_thread_idle_gethandler() -> rt_thread_t;
}
extern "C" {
    pub fn rt_system_scheduler_init();
}
extern "C" {
    pub fn rt_system_scheduler_start();
}
extern "C" {
    pub fn rt_schedule();
}
extern "C" {
    pub fn rt_schedule_insert_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_schedule_remove_thread(thread: *mut rt_thread);
}
extern "C" {
    pub fn rt_enter_critical();
}
extern "C" {
    pub fn rt_exit_critical();
}
extern "C" {
    pub fn rt_critical_level() -> rt_uint16_t;
}
extern "C" {
    pub fn rt_scheduler_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(from: rt_thread_t, to: rt_thread_t)>,
    );
}
extern "C" {
    pub fn rt_scheduler_switch_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(tid: *mut rt_thread)>,
    );
}
extern "C" {
    pub fn rt_secondary_cpu_entry();
}
extern "C" {
    pub fn rt_scheduler_ipi_handler(vector: core::ffi::c_int, param: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_mp_init(
        mp: *mut rt_mempool,
        name: *const core::ffi::c_char,
        start: *mut core::ffi::c_void,
        size: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_detach(mp: *mut rt_mempool) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_create(
        name: *const core::ffi::c_char,
        block_count: rt_size_t,
        block_size: rt_size_t,
    ) -> rt_mp_t;
}
extern "C" {
    pub fn rt_mp_delete(mp: rt_mp_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mp_alloc(mp: rt_mp_t, time: rt_int32_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_mp_free(block: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_mp_alloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut core::ffi::c_void),
        >,
    );
}
extern "C" {
    pub fn rt_mp_free_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(mp: *mut rt_mempool, block: *mut core::ffi::c_void),
        >,
    );
}
extern "C" {
    pub fn rt_system_heap_init(
        begin_addr: *mut core::ffi::c_void,
        end_addr: *mut core::ffi::c_void,
    );
}
extern "C" {
    pub fn rt_malloc(size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_realloc(ptr: *mut core::ffi::c_void, newsize: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_calloc(count: rt_size_t, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_malloc_align(size: rt_size_t, align: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_free_align(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_memory_info(total: *mut rt_size_t, used: *mut rt_size_t, max_used: *mut rt_size_t);
}
extern "C" {
    pub fn rt_malloc_sethook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut core::ffi::c_void, size: rt_size_t),
        >,
    );
}
extern "C" {
    pub fn rt_free_sethook(
        hook: ::core::option::Option<unsafe extern "C" fn(ptr: *mut core::ffi::c_void)>,
    );
}
extern "C" {
    #[doc = " memory heap object interface"]
    pub fn rt_memheap_init(
        memheap: *mut rt_memheap,
        name: *const core::ffi::c_char,
        start_addr: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_memheap_detach(heap: *mut rt_memheap) -> rt_err_t;
}
extern "C" {
    pub fn rt_memheap_alloc(heap: *mut rt_memheap, size: rt_size_t) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memheap_realloc(
        heap: *mut rt_memheap,
        ptr: *mut core::ffi::c_void,
        newsize: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memheap_free(ptr: *mut core::ffi::c_void);
}
extern "C" {
    pub fn rt_memheap_info(
        heap: *mut rt_memheap,
        total: *mut rt_size_t,
        used: *mut rt_size_t,
        max_used: *mut rt_size_t,
    );
}
extern "C" {
    pub fn rt_sem_init(
        sem: rt_sem_t,
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_detach(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_create(
        name: *const core::ffi::c_char,
        value: rt_uint32_t,
        flag: rt_uint8_t,
    ) -> rt_sem_t;
}
extern "C" {
    pub fn rt_sem_delete(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_interruptible(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_take_killable(sem: rt_sem_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_trytake(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_release(sem: rt_sem_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_sem_control(
        sem: rt_sem_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_init(
        mutex: rt_mutex_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_detach(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_mutex_t;
}
extern "C" {
    pub fn rt_mutex_delete(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_drop_thread(mutex: rt_mutex_t, thread: rt_thread_t);
}
extern "C" {
    pub fn rt_mutex_setprioceiling(mutex: rt_mutex_t, priority: rt_uint8_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_getprioceiling(mutex: rt_mutex_t) -> rt_uint8_t;
}
extern "C" {
    pub fn rt_mutex_take(mutex: rt_mutex_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_trytake(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_interruptible(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_take_killable(mutex: rt_mutex_t, time: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_release(mutex: rt_mutex_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mutex_control(
        mutex: rt_mutex_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_init(
        event: rt_event_t,
        name: *const core::ffi::c_char,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_detach(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_create(name: *const core::ffi::c_char, flag: rt_uint8_t) -> rt_event_t;
}
extern "C" {
    pub fn rt_event_delete(event: rt_event_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_send(event: rt_event_t, set: rt_uint32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_interruptible(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_recv_killable(
        event: rt_event_t,
        set: rt_uint32_t,
        opt: rt_uint8_t,
        timeout: rt_int32_t,
        recved: *mut rt_uint32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_event_control(
        event: rt_event_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_init(
        mb: rt_mailbox_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_detach(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_create(
        name: *const core::ffi::c_char,
        size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mailbox_t;
}
extern "C" {
    pub fn rt_mb_delete(mb: rt_mailbox_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait(mb: rt_mailbox_t, value: rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_interruptible(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_send_wait_killable(
        mb: rt_mailbox_t,
        value: rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_urgent(mb: rt_mailbox_t, value: rt_ubase_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv(mb: rt_mailbox_t, value: *mut rt_ubase_t, timeout: rt_int32_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_interruptible(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_recv_killable(
        mb: rt_mailbox_t,
        value: *mut rt_ubase_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mb_control(
        mb: rt_mailbox_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_mq_message {
    pub next: *mut rt_mq_message,
    pub length: rt_ssize_t,
    pub prio: rt_int32_t,
}
#[test]
fn bindgen_test_layout_rt_mq_message() {
    const UNINIT: ::core::mem::MaybeUninit<rt_mq_message> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<rt_mq_message>(),
        12usize,
        concat!("Size of: ", stringify!(rt_mq_message))
    );
    assert_eq!(
        ::core::mem::align_of::<rt_mq_message>(),
        4usize,
        concat!("Alignment of ", stringify!(rt_mq_message))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rt_mq_message),
            "::",
            stringify!(prio)
        )
    );
}
extern "C" {
    pub fn rt_mq_init(
        mq: rt_mq_t,
        name: *const core::ffi::c_char,
        msgpool: *mut core::ffi::c_void,
        msg_size: rt_size_t,
        pool_size: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_detach(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_create(
        name: *const core::ffi::c_char,
        msg_size: rt_size_t,
        max_msgs: rt_size_t,
        flag: rt_uint8_t,
    ) -> rt_mq_t;
}
extern "C" {
    pub fn rt_mq_delete(mq: rt_mq_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_interruptible(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_killable(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_urgent(mq: rt_mq_t, buffer: *const core::ffi::c_void, size: rt_size_t)
        -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_interruptible(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_recv_killable(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        timeout: rt_int32_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_mq_control(
        mq: rt_mq_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_send_wait_prio(
        mq: rt_mq_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
        prio: rt_int32_t,
        timeout: rt_int32_t,
        suspend_flag: core::ffi::c_int,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_mq_recv_prio(
        mq: rt_mq_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
        prio: *mut rt_int32_t,
        timeout: rt_int32_t,
        suspend_flag: core::ffi::c_int,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_thread_defunct_enqueue(thread: rt_thread_t);
}
extern "C" {
    pub fn rt_thread_defunct_dequeue() -> rt_thread_t;
}
extern "C" {
    pub fn rt_spin_lock_init(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_unlock(lock: *mut rt_spinlock);
}
extern "C" {
    pub fn rt_spin_lock_irqsave(lock: *mut rt_spinlock) -> rt_base_t;
}
extern "C" {
    pub fn rt_spin_unlock_irqrestore(lock: *mut rt_spinlock, level: rt_base_t);
}
extern "C" {
    #[doc = " @addtogroup Device\n @{"]
    pub fn rt_device_find(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_register(
        dev: rt_device_t,
        name: *const core::ffi::c_char,
        flags: rt_uint16_t,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_unregister(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_create(type_: core::ffi::c_int, attach_size: core::ffi::c_int) -> rt_device_t;
}
extern "C" {
    pub fn rt_device_destroy(device: rt_device_t);
}
extern "C" {
    pub fn rt_device_set_rx_indicate(
        dev: rt_device_t,
        rx_ind: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, size: rt_size_t) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_set_tx_complete(
        dev: rt_device_t,
        tx_done: ::core::option::Option<
            unsafe extern "C" fn(dev: rt_device_t, buffer: *mut core::ffi::c_void) -> rt_err_t,
        >,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_init(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_open(dev: rt_device_t, oflag: rt_uint16_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_close(dev: rt_device_t) -> rt_err_t;
}
extern "C" {
    pub fn rt_device_read(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *mut core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_write(
        dev: rt_device_t,
        pos: rt_off_t,
        buffer: *const core::ffi::c_void,
        size: rt_size_t,
    ) -> rt_ssize_t;
}
extern "C" {
    pub fn rt_device_control(
        dev: rt_device_t,
        cmd: core::ffi::c_int,
        arg: *mut core::ffi::c_void,
    ) -> rt_err_t;
}
extern "C" {
    pub fn rt_interrupt_enter();
}
extern "C" {
    pub fn rt_interrupt_leave();
}
extern "C" {
    pub fn rt_cpus_lock() -> rt_base_t;
}
extern "C" {
    pub fn rt_cpus_unlock(level: rt_base_t);
}
extern "C" {
    pub fn rt_interrupt_get_nest() -> rt_uint8_t;
}
extern "C" {
    pub fn rt_interrupt_enter_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_interrupt_leave_sethook(hook: ::core::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    pub fn rt_components_init();
}
extern "C" {
    pub fn rt_components_board_init();
}
extern "C" {
    pub fn rt_kprintf(fmt: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_kputs(str_: *const core::ffi::c_char);
}
extern "C" {
    pub fn rt_vsprintf(
        dest: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        arg_ptr: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_vsnprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        fmt: *const core::ffi::c_char,
        args: va_list,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_sprintf(
        buf: *mut core::ffi::c_char,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_snprintf(
        buf: *mut core::ffi::c_char,
        size: rt_size_t,
        format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_console_set_device(name: *const core::ffi::c_char) -> rt_device_t;
}
extern "C" {
    pub fn rt_console_get_device() -> rt_device_t;
}
extern "C" {
    pub fn rt_get_errno() -> rt_err_t;
}
extern "C" {
    pub fn rt_set_errno(no: rt_err_t);
}
extern "C" {
    pub fn _rt_errno() -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn rt_strerror(error: rt_err_t) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn __rt_ffs(value: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn rt_memset(
        src: *mut core::ffi::c_void,
        c: core::ffi::c_int,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcpy(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_ubase_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memmove(
        dest: *mut core::ffi::c_void,
        src: *const core::ffi::c_void,
        n: rt_size_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn rt_memcmp(
        cs: *const core::ffi::c_void,
        ct: *const core::ffi::c_void,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strdup(s: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strnlen(s: *const core::ffi::c_char, maxlen: rt_ubase_t) -> rt_size_t;
}
extern "C" {
    pub fn rt_strstr(
        str1: *const core::ffi::c_char,
        str2: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strcasecmp(a: *const core::ffi::c_char, b: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcpy(
        dst: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncpy(
        dest: *mut core::ffi::c_char,
        src: *const core::ffi::c_char,
        n: rt_size_t,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn rt_strncmp(
        cs: *const core::ffi::c_char,
        ct: *const core::ffi::c_char,
        count: rt_size_t,
    ) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strcmp(cs: *const core::ffi::c_char, ct: *const core::ffi::c_char) -> rt_int32_t;
}
extern "C" {
    pub fn rt_strlen(src: *const core::ffi::c_char) -> rt_size_t;
}
extern "C" {
    pub fn rt_show_version();
}
extern "C" {
    pub static mut rt_assert_hook: ::core::option::Option<
        unsafe extern "C" fn(
            ex: *const core::ffi::c_char,
            func: *const core::ffi::c_char,
            line: rt_size_t,
        ),
    >;
}
extern "C" {
    pub fn rt_assert_set_hook(
        hook: ::core::option::Option<
            unsafe extern "C" fn(
                ex: *const core::ffi::c_char,
                func: *const core::ffi::c_char,
                line: rt_size_t,
            ),
        >,
    );
}
extern "C" {
    pub fn rt_assert_handler(
        ex: *const core::ffi::c_char,
        func: *const core::ffi::c_char,
        line: rt_size_t,
    );
}
pub const unwind_reason_code_URC_OK: unwind_reason_code = 0;
pub const unwind_reason_code_URC_CONTINUE_UNWIND: unwind_reason_code = 8;
pub const unwind_reason_code_URC_FAILURE: unwind_reason_code = 9;
pub type unwind_reason_code = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unwind_idx {
    pub addr_offset: core::ffi::c_ulong,
    pub insn: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_unwind_idx() {
    const UNINIT: ::core::mem::MaybeUninit<unwind_idx> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unwind_idx>(),
        8usize,
        concat!("Size of: ", stringify!(unwind_idx))
    );
    assert_eq!(
        ::core::mem::align_of::<unwind_idx>(),
        4usize,
        concat!("Alignment of ", stringify!(unwind_idx))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_idx),
            "::",
            stringify!(addr_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_idx),
            "::",
            stringify!(insn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unwind_table {
    pub start: *const unwind_idx,
    pub origin: *const unwind_idx,
    pub stop: *const unwind_idx,
    pub begin_addr: core::ffi::c_ulong,
    pub end_addr: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_unwind_table() {
    const UNINIT: ::core::mem::MaybeUninit<unwind_table> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<unwind_table>(),
        20usize,
        concat!("Size of: ", stringify!(unwind_table))
    );
    assert_eq!(
        ::core::mem::align_of::<unwind_table>(),
        4usize,
        concat!("Alignment of ", stringify!(unwind_table))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_table),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_table),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_table),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).begin_addr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_table),
            "::",
            stringify!(begin_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end_addr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unwind_table),
            "::",
            stringify!(end_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stackframe {
    pub fp: core::ffi::c_ulong,
    pub sp: core::ffi::c_ulong,
    pub lr: core::ffi::c_ulong,
    pub pc: core::ffi::c_ulong,
}
#[test]
fn bindgen_test_layout_stackframe() {
    const UNINIT: ::core::mem::MaybeUninit<stackframe> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stackframe>(),
        16usize,
        concat!("Size of: ", stringify!(stackframe))
    );
    assert_eq!(
        ::core::mem::align_of::<stackframe>(),
        4usize,
        concat!("Alignment of ", stringify!(stackframe))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stackframe),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stackframe),
            "::",
            stringify!(sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stackframe),
            "::",
            stringify!(lr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stackframe),
            "::",
            stringify!(pc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pt_regs {
    pub uregs: [core::ffi::c_ulong; 18usize],
}
#[test]
fn bindgen_test_layout_pt_regs() {
    const UNINIT: ::core::mem::MaybeUninit<pt_regs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pt_regs>(),
        72usize,
        concat!("Size of: ", stringify!(pt_regs))
    );
    assert_eq!(
        ::core::mem::align_of::<pt_regs>(),
        4usize,
        concat!("Alignment of ", stringify!(pt_regs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).uregs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pt_regs),
            "::",
            stringify!(uregs)
        )
    );
}
extern "C" {
    pub fn unwind_frame(
        frame: *mut stackframe,
        origin_idx: *mut *const unwind_idx,
        exidx_start: *const unwind_idx,
        exidx_end: *const unwind_idx,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn unwind_backtrace(
        regs: *mut pt_regs,
        exidx_start: *const unwind_idx,
        exidx_end: *const unwind_idx,
    );
}
extern "C" {
    pub fn rt_unwind(regs: *mut rt_hw_exp_stack, pc_adj: core::ffi::c_uint);
}
extern "C" {
    pub fn rt_backtrace();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dfs_file_ops {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filesystem_ops {
    pub _address: u8,
}
